{"ast":null,"code":"import { Map } from \"immutable\";\nimport RungeKutta from \"../RungeKutta/RungeKutta.service\";\nexport var makePendulum = function makePendulum() {\n  return Map({\n    aMass: 100,\n    aLength: 50 + Math.random() * 80,\n    aAngle: Math.PI + Math.random() * 1 - 0.5,\n    aAngularVelocity: 0,\n    aAngAccel: 0,\n    bMass: 50,\n    bLength: 50,\n    bAngle: Math.random() * 6,\n    bAngularVelocity: 0,\n    bAngAccel: 0\n  });\n};\nvar GRAVITY = 9.8;\nvar SPEED = 0.1;\n/**\n * This system of equations has 4 variables\n * the angular velocity of a,\n * the angular velocity of b,\n * the angle of a,\n * the angle of b.\n *\n * So, we need to create a function which takes in those four variables, and calculates everything else from that.\n * Hopefully this won't be super confusing to future me, but this function takes in a pendulum, and returns a function\n * that does that.\n */\n\nvar getRungeKuttaFunctionForPendulum = function getRungeKuttaFunctionForPendulum(p) {\n  return function (v) {\n    // This is from a website. (https://www.myphysicslab.com/pendulum/double-pendulum-en.html)\n    // Also I realize that p. and v. look very similar which might make the following hard to debug / read\n    // (like it wasn't hard already)\n    // Sorry future me.\n    // Declare all the values I need so that I don't have to worry about whether their undefined.\n    var pAMass = p.get(\"aMass\") || 0;\n    var pBMass = p.get(\"bMass\") || 0;\n    var pALength = p.get(\"aLength\") || 0;\n    var pBLength = p.get(\"bLength\") || 0;\n    var vAngA = v.get(\"angA\") || 0;\n    var vAngB = v.get(\"angB\") || 0;\n    var vVelA = v.get(\"velA\") || 0;\n    var vVelB = v.get(\"velB\") || 0;\n    var angVelA = vVelA;\n    var angVelB = vVelB;\n    var angAccelA = (-GRAVITY * (2 * pAMass + pBMass) * Math.sin(vAngA) - pBMass * GRAVITY * Math.sin(vAngA - 2 * vAngB) - 2 * Math.sin(vAngA - vAngB) * pBMass * (Math.pow(vVelB, 2) * pBLength + Math.pow(vVelA, 2) * pALength * Math.cos(vAngA - vAngB))) / (pALength * (2 * pAMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n    var angAccelB = 2 * Math.sin(vAngA - vAngB) * (Math.pow(vVelA, 2) * pALength * (pAMass + pBMass) + GRAVITY * (pAMass + pBMass * Math.cos(vAngA + Math.pow(vVelB, 2) * pBLength * pBMass * Math.cos(vAngA - vAngB)))) / (pBLength * (2 * pBMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n    return Map({\n      velA: angAccelA,\n      velB: angAccelB,\n      angA: angVelA,\n      angB: angVelB\n    });\n  };\n};\n/**\n * Simulates chaotic pendulums utilizing the Runge-Katta algorithm\n */\n\n\nvar getNextPendulum = function getNextPendulum(prevPendulum) {\n  // Ok, so the next few lines are going to get pretty complicated.\n  // Just bear with me, we'll make it through together.\n\n  /* This is really condensed.\n   * RungeKutta takes in a function of the form specified by the runge katta algorithm\n   * and returns a function which we can use to calculate the next state of a simulation\n   * after some time.  We then store the result of this next state in the map variable.\n   * after that, we return the previous pendulum with the populated with the values\n   * from this map variable (it's an immutable.js map, so we're not mutating anything)\n   */\n  var map = RungeKutta(getRungeKuttaFunctionForPendulum(prevPendulum))(Map({\n    angA: prevPendulum.get(\"aAngle\"),\n    angB: prevPendulum.get(\"bAngle\"),\n    velA: prevPendulum.get(\"aAngularVelocity\"),\n    velB: prevPendulum.get(\"bAngularVelocity\")\n  }), SPEED);\n  return prevPendulum.set(\"aAngle\", map.get(\"angA\") || 0).set(\"bAngle\", map.get(\"angB\") || 0).set(\"aAngularVelocity\", map.get(\"velA\") || 0).set(\"bAngularVelocity\", map.get(\"velB\") || 0);\n};\n\nexport default getNextPendulum;","map":null,"metadata":{},"sourceType":"module"}