{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime-corejs2/helpers/esm/taggedTemplateLiteral\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"/Users/danielkrajnak/Documents/Code/dankLand/src/View/PageComponents/Menu/CardMenu/CardDeck/CardDeck.tsx\";\nvar __jsx = React.createElement;\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n  position: fixed;\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  height: \", \"px;\\n  width: 100%;\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport useScrollAmount from \"../../../../Hooks/useScrollAmount\";\nimport Card from \"../Card/Card\";\nimport useFullScreen from \"../../../../Hooks/useFullScreen\";\nimport { mappedStepEaser } from \"../../../../../Services/EaseStep/EaseStep.service\";\nimport EasingFunctions from \"../../../../../Services/Ease/Ease.service\";\nimport Link from \"next/link\";\nimport useSafeWindow from \"../../../../Hooks/useSafeWindow\"; // TODO find a better way to do this.\n// @ts-ignore\n\nvar _ref = {},\n    width = _ref.width,\n    height = _ref.height,\n    CardPropsSubset = _objectWithoutProperties(_ref, [\"width\", \"height\"]);\n\nvar CardDeckHolder = styled.div(_templateObject(), function (props) {\n  return props.height;\n});\nvar CardHolder = styled.div.attrs(function (props) {\n  return {\n    style: {\n      transform: \"translate(\".concat(props.dx, \"px, \").concat(props.dy, \"px)\"),\n      zIndex: 2000 - props.order\n    }\n  };\n})(_templateObject2());\nvar PERIOD = 0.4;\nvar EASING_FUNCTION = EasingFunctions.easeInOutQuart;\n/**\n * Creates a scrollable Card Deck.\n * @param {Props} props\n */\n\nvar CardDeck = function CardDeck(props) {\n  var scroll = useScrollAmount(true);\n\n  var _useSafeWindow = useSafeWindow(),\n      _useSafeWindow2 = _slicedToArray(_useSafeWindow, 1),\n      window = _useSafeWindow2[0];\n\n  var _useFullScreen = useFullScreen(),\n      _useFullScreen2 = _slicedToArray(_useFullScreen, 3),\n      windowWidth = _useFullScreen2[0],\n      windowHeight = _useFullScreen2[1],\n      flash = _useFullScreen2[2]; // This is the position on the screen the deck sits.  It's a computed value based on the windowWidth.\n\n\n  var deckPosition = React.useMemo(function () {\n    return (windowWidth - props.cardsWidth) / 2;\n  }, [props.cardsWidth, windowWidth]);\n  var scrollDemap = React.useMemo(function () {\n    return function (val) {\n      return deckPosition - windowWidth * val;\n    };\n  }, [deckPosition, windowWidth]);\n  var scrollLength = windowHeight * 5;\n  var cardPositionStart = deckPosition;\n  var cardPositionEnd = -props.cardsWidth; // Memoize stepEaser to only generate range and getPosition when the cards length changes.\n\n  var _React$useMemo = React.useMemo(function () {\n    return mappedStepEaser(0, scrollLength, cardPositionStart, cardPositionEnd)(props.cards.length - 1, PERIOD, EASING_FUNCTION);\n  }, [cardPositionEnd, cardPositionStart, props.cards.length, scrollLength]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      getPosition = _React$useMemo2[0],\n      getEaseStart = _React$useMemo2[1]; // Move to the saved scroll position when this component renders\n\n\n  React.useLayoutEffect(function () {\n    var timeout;\n\n    if (window) {\n      if (props.scrollToCard) {\n        //Ok, this is hacky, but unless we wait a few milliseconds,\n        // the screen doesn't have time to render and we don't scroll anywhere.\n        // As far as I can tell for now, there's no way to listen for when all the cards have been rendered\n        setTimeout(function () {\n          if (props.scrollToCard) {\n            window.scrollTo(0, // Add a little to the index to give make sure the card on top has moved off of the card below\n            // TODO this should take the easing function into account.\n            getEaseStart(props.scrollToCard + 2 / props.cards.length));\n          }\n        }, 15);\n      }\n    }\n\n    return function () {\n      clearTimeout(timeout);\n    };\n  }, [getEaseStart, props.cards.length, props.scrollToCard, window]);\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(CardDeckHolder, {\n    height: scrollLength + windowHeight,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111\n    },\n    __self: this\n  }, props.cards.map(function (card, i) {\n    // Only draw cards when the card above it has moved and it's on screen.\n    var nextCardPosition = i !== props.cards.length - 1 ? getPosition(scroll, i + 1) : cardPositionStart;\n    var currentCardPosition = getPosition(scroll, i);\n    var prevCardPosition = i !== 0 ? getPosition(scroll, i - 1) : cardPositionEnd;\n    var shouldNotDrawCard = currentCardPosition === nextCardPosition && currentCardPosition !== deckPosition || prevCardPosition === cardPositionStart;\n    return __jsx(Link, {\n      href: card.link,\n      key: i,\n      className: \"card-deck-card-link\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 128\n      },\n      __self: this\n    }, __jsx(CardHolder, {\n      dx: i === props.cards.length - 1 ? cardPositionStart : currentCardPosition,\n      dy: (windowHeight - props.cardsHeight) / 2,\n      order: i,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129\n      },\n      __self: this\n    }, !shouldNotDrawCard && __jsx(Card, _extends({}, card, {\n      width: props.cardsWidth,\n      height: props.cardsHeight,\n      shadowAmount: i === props.cards.length - 1 ? 0 : scrollDemap(getPosition(scroll, i)),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    }))));\n  }));\n};\n\nexport default CardDeck;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/View/PageComponents/Menu/CardMenu/CardDeck/CardDeck.tsx"],"names":["React","styled","useScrollAmount","Card","useFullScreen","mappedStepEaser","EasingFunctions","Link","useSafeWindow","width","height","CardPropsSubset","CardDeckHolder","div","props","CardHolder","attrs","style","transform","dx","dy","zIndex","order","PERIOD","EASING_FUNCTION","easeInOutQuart","CardDeck","scroll","window","windowWidth","windowHeight","flash","deckPosition","useMemo","cardsWidth","scrollDemap","val","scrollLength","cardPositionStart","cardPositionEnd","cards","length","getPosition","getEaseStart","useLayoutEffect","timeout","scrollToCard","setTimeout","scrollTo","clearTimeout","map","card","i","nextCardPosition","currentCardPosition","prevCardPosition","shouldNotDrawCard","link","cardsHeight"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,MAAP,MAAwC,mBAAxC;AACA,OAAOC,eAAP,MAA4B,mCAA5B;AACA,OAAOC,IAAP,MAAyC,cAAzC;AACA,OAAOC,aAAP,MAA0B,iCAA1B;AACA,SAASC,eAAT,QAAgC,mDAAhC;AACA,OAAOC,eAAP,MAA4B,2CAA5B;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,OAAOC,aAAP,MAA0B,iCAA1B,C,CAEA;AACA;;WACyD,E;IAAjDC,K,QAAAA,K;IAAOC,M,QAAAA,M;IAAWC,e;;AAU1B,IAAMC,cAAc,GAAGX,MAAM,CAACY,GAAV,oBACR,UAAAC,KAAK;AAAA,SAAIA,KAAK,CAACJ,MAAV;AAAA,CADG,CAApB;AAKA,IAAMK,UAAU,GAAGd,MAAM,CAACY,GAAP,CAAWG,KAAX,CACjB,UAAAF,KAAK;AAAA,SAAK;AACRG,IAAAA,KAAK,EAAE;AACLC,MAAAA,SAAS,sBAAeJ,KAAK,CAACK,EAArB,iBAA8BL,KAAK,CAACM,EAApC,QADJ;AAELC,MAAAA,MAAM,EAAE,OAAOP,KAAK,CAACQ;AAFhB;AADC,GAAL;AAAA,CADY,CAAH,oBAAhB;AAgBA,IAAMC,MAAM,GAAG,GAAf;AACA,IAAMC,eAAe,GAAGlB,eAAe,CAACmB,cAAxC;AAEA;;;;;AAIA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACZ,KAAD,EAAkB;AACjC,MAAMa,MAAM,GAAGzB,eAAe,CAAC,IAAD,CAA9B;;AADiC,uBAEhBM,aAAa,EAFG;AAAA;AAAA,MAE1BoB,MAF0B;;AAAA,uBAIUxB,aAAa,EAJvB;AAAA;AAAA,MAI1ByB,WAJ0B;AAAA,MAIbC,YAJa;AAAA,MAICC,KAJD,uBAMjC;;;AACA,MAAMC,YAAY,GAAGhC,KAAK,CAACiC,OAAN,CACnB;AAAA,WAAM,CAACJ,WAAW,GAAGf,KAAK,CAACoB,UAArB,IAAmC,CAAzC;AAAA,GADmB,EAEnB,CAACpB,KAAK,CAACoB,UAAP,EAAmBL,WAAnB,CAFmB,CAArB;AAKA,MAAMM,WAAW,GAAGnC,KAAK,CAACiC,OAAN,CAClB;AAAA,WAAM,UAACG,GAAD;AAAA,aAAiBJ,YAAY,GAAGH,WAAW,GAAGO,GAA9C;AAAA,KAAN;AAAA,GADkB,EAElB,CAACJ,YAAD,EAAeH,WAAf,CAFkB,CAApB;AAKA,MAAMQ,YAAY,GAAGP,YAAY,GAAG,CAApC;AACA,MAAMQ,iBAAiB,GAAGN,YAA1B;AACA,MAAMO,eAAe,GAAG,CAACzB,KAAK,CAACoB,UAA/B,CAnBiC,CAoBjC;;AApBiC,uBAqBGlC,KAAK,CAACiC,OAAN,CAClC;AAAA,WACE5B,eAAe,CAAC,CAAD,EAAIgC,YAAJ,EAAkBC,iBAAlB,EAAqCC,eAArC,CAAf,CACEzB,KAAK,CAAC0B,KAAN,CAAYC,MAAZ,GAAqB,CADvB,EAEElB,MAFF,EAGEC,eAHF,CADF;AAAA,GADkC,EAOlC,CAACe,eAAD,EAAkBD,iBAAlB,EAAqCxB,KAAK,CAAC0B,KAAN,CAAYC,MAAjD,EAAyDJ,YAAzD,CAPkC,CArBH;AAAA;AAAA,MAqB1BK,WArB0B;AAAA,MAqBbC,YArBa,uBA+BjC;;;AACA3C,EAAAA,KAAK,CAAC4C,eAAN,CAAsB,YAAM;AAC1B,QAAIC,OAAJ;;AACA,QAAIjB,MAAJ,EAAY;AACV,UAAId,KAAK,CAACgC,YAAV,EAAwB;AACtB;AACA;AACA;AACAC,QAAAA,UAAU,CAAC,YAAM;AACf,cAAIjC,KAAK,CAACgC,YAAV,EAAwB;AACtBlB,YAAAA,MAAM,CAACoB,QAAP,CACE,CADF,EAEE;AACA;AACAL,YAAAA,YAAY,CAAC7B,KAAK,CAACgC,YAAN,GAAqB,IAAIhC,KAAK,CAAC0B,KAAN,CAAYC,MAAtC,CAJd;AAMD;AACF,SATS,EASP,EATO,CAAV;AAUD;AACF;;AACD,WAAO,YAAM;AACXQ,MAAAA,YAAY,CAACJ,OAAD,CAAZ;AACD,KAFD;AAGD,GAtBD,EAsBG,CAACF,YAAD,EAAe7B,KAAK,CAAC0B,KAAN,CAAYC,MAA3B,EAAmC3B,KAAK,CAACgC,YAAzC,EAAuDlB,MAAvD,CAtBH;;AAwBA,MAAIG,KAAJ,EAAW;AACT,WAAOA,KAAP;AACD;;AACD,SACE,MAAC,cAAD;AAAgB,IAAA,MAAM,EAAEM,YAAY,GAAGP,YAAvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGhB,KAAK,CAAC0B,KAAN,CAAYU,GAAZ,CAAgB,UAACC,IAAD,EAAOC,CAAP,EAAa;AAC5B;AACA,QAAMC,gBAAgB,GACpBD,CAAC,KAAKtC,KAAK,CAAC0B,KAAN,CAAYC,MAAZ,GAAqB,CAA3B,GACIC,WAAW,CAACf,MAAD,EAASyB,CAAC,GAAG,CAAb,CADf,GAEId,iBAHN;AAIA,QAAMgB,mBAAmB,GAAGZ,WAAW,CAACf,MAAD,EAASyB,CAAT,CAAvC;AACA,QAAMG,gBAAgB,GACpBH,CAAC,KAAK,CAAN,GAAUV,WAAW,CAACf,MAAD,EAASyB,CAAC,GAAG,CAAb,CAArB,GAAuCb,eADzC;AAGA,QAAMiB,iBAAiB,GACpBF,mBAAmB,KAAKD,gBAAxB,IACCC,mBAAmB,KAAKtB,YAD1B,IAEAuB,gBAAgB,KAAKjB,iBAHvB;AAKA,WACE,MAAC,IAAD;AAAM,MAAA,IAAI,EAAEa,IAAI,CAACM,IAAjB;AAAuB,MAAA,GAAG,EAAEL,CAA5B;AAA+B,MAAA,SAAS,EAAC,qBAAzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE,MAAC,UAAD;AACE,MAAA,EAAE,EACAA,CAAC,KAAKtC,KAAK,CAAC0B,KAAN,CAAYC,MAAZ,GAAqB,CAA3B,GACIH,iBADJ,GAEIgB,mBAJR;AAME,MAAA,EAAE,EAAE,CAACxB,YAAY,GAAGhB,KAAK,CAAC4C,WAAtB,IAAqC,CAN3C;AAOE,MAAA,KAAK,EAAEN,CAPT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OASG,CAACI,iBAAD,IACC,MAAC,IAAD,eACML,IADN;AAEE,MAAA,KAAK,EAAErC,KAAK,CAACoB,UAFf;AAGE,MAAA,MAAM,EAAEpB,KAAK,CAAC4C,WAHhB;AAIE,MAAA,YAAY,EACVN,CAAC,KAAKtC,KAAK,CAAC0B,KAAN,CAAYC,MAAZ,GAAqB,CAA3B,GACI,CADJ,GAEIN,WAAW,CAACO,WAAW,CAACf,MAAD,EAASyB,CAAT,CAAZ,CAPnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAVJ,CADF,CADF;AA0BD,GAzCA,CADH,CADF;AA8CD,CAzGD;;AA0GA,eAAe1B,QAAf","sourcesContent":["import * as React from \"react\";\nimport styled, { StyledComponent } from \"styled-components\";\nimport useScrollAmount from \"../../../../Hooks/useScrollAmount\";\nimport Card, { Props as CardProps } from \"../Card/Card\";\nimport useFullScreen from \"../../../../Hooks/useFullScreen\";\nimport { mappedStepEaser } from \"../../../../../Services/EaseStep/EaseStep.service\";\nimport EasingFunctions from \"../../../../../Services/Ease/Ease.service\";\nimport Link from \"next/link\";\nimport useSafeWindow from \"../../../../Hooks/useSafeWindow\";\n\n// TODO find a better way to do this.\n// @ts-ignore\nconst { width, height, ...CardPropsSubset }: CardProps = {};\ninterface Props {\n  cards: ({\n    link: string;\n  } & typeof CardPropsSubset)[];\n  width: number;\n  cardsWidth: number;\n  cardsHeight: number;\n  scrollToCard?: number | null;\n}\nconst CardDeckHolder = styled.div<{ height: number }>`\n  height: ${props => props.height}px;\n  width: 100%;\n`;\n\nconst CardHolder = styled.div.attrs<{ dx: number; dy: number; order: number }>(\n  props => ({\n    style: {\n      transform: `translate(${props.dx}px, ${props.dy}px)`,\n      zIndex: 2000 - props.order,\n    },\n  })\n)`\n  position: fixed;\n` as StyledComponent<\n  \"div\",\n  any,\n  { dx: number; dy: number; order: number },\n  never\n>;\n\nconst PERIOD = 0.4;\nconst EASING_FUNCTION = EasingFunctions.easeInOutQuart;\n\n/**\n * Creates a scrollable Card Deck.\n * @param {Props} props\n */\nconst CardDeck = (props: Props) => {\n  const scroll = useScrollAmount(true);\n  const [window] = useSafeWindow();\n\n  const [windowWidth, windowHeight, flash] = useFullScreen();\n\n  // This is the position on the screen the deck sits.  It's a computed value based on the windowWidth.\n  const deckPosition = React.useMemo(\n    () => (windowWidth - props.cardsWidth) / 2,\n    [props.cardsWidth, windowWidth]\n  );\n\n  const scrollDemap = React.useMemo(\n    () => (val: number) => deckPosition - windowWidth * val,\n    [deckPosition, windowWidth]\n  );\n\n  const scrollLength = windowHeight * 5;\n  const cardPositionStart = deckPosition;\n  const cardPositionEnd = -props.cardsWidth;\n  // Memoize stepEaser to only generate range and getPosition when the cards length changes.\n  const [getPosition, getEaseStart] = React.useMemo(\n    () =>\n      mappedStepEaser(0, scrollLength, cardPositionStart, cardPositionEnd)(\n        props.cards.length - 1,\n        PERIOD,\n        EASING_FUNCTION\n      ),\n    [cardPositionEnd, cardPositionStart, props.cards.length, scrollLength]\n  );\n\n  // Move to the saved scroll position when this component renders\n  React.useLayoutEffect(() => {\n    let timeout: number;\n    if (window) {\n      if (props.scrollToCard) {\n        //Ok, this is hacky, but unless we wait a few milliseconds,\n        // the screen doesn't have time to render and we don't scroll anywhere.\n        // As far as I can tell for now, there's no way to listen for when all the cards have been rendered\n        setTimeout(() => {\n          if (props.scrollToCard) {\n            window.scrollTo(\n              0,\n              // Add a little to the index to give make sure the card on top has moved off of the card below\n              // TODO this should take the easing function into account.\n              getEaseStart(props.scrollToCard + 2 / props.cards.length)\n            );\n          }\n        }, 15);\n      }\n    }\n    return () => {\n      clearTimeout(timeout);\n    };\n  }, [getEaseStart, props.cards.length, props.scrollToCard, window]);\n\n  if (flash) {\n    return flash;\n  }\n  return (\n    <CardDeckHolder height={scrollLength + windowHeight}>\n      {props.cards.map((card, i) => {\n        // Only draw cards when the card above it has moved and it's on screen.\n        const nextCardPosition =\n          i !== props.cards.length - 1\n            ? getPosition(scroll, i + 1)\n            : cardPositionStart;\n        const currentCardPosition = getPosition(scroll, i);\n        const prevCardPosition =\n          i !== 0 ? getPosition(scroll, i - 1) : cardPositionEnd;\n\n        const shouldNotDrawCard =\n          (currentCardPosition === nextCardPosition &&\n            currentCardPosition !== deckPosition) ||\n          prevCardPosition === cardPositionStart;\n\n        return (\n          <Link href={card.link} key={i} className=\"card-deck-card-link\">\n            <CardHolder\n              dx={\n                i === props.cards.length - 1\n                  ? cardPositionStart\n                  : currentCardPosition\n              }\n              dy={(windowHeight - props.cardsHeight) / 2}\n              order={i}\n            >\n              {!shouldNotDrawCard && (\n                <Card\n                  {...card}\n                  width={props.cardsWidth}\n                  height={props.cardsHeight}\n                  shadowAmount={\n                    i === props.cards.length - 1\n                      ? 0\n                      : scrollDemap(getPosition(scroll, i))\n                  }\n                />\n              )}\n            </CardHolder>\n          </Link>\n        );\n      })}\n    </CardDeckHolder>\n  );\n};\nexport default CardDeck;\n"]},"metadata":{},"sourceType":"module"}