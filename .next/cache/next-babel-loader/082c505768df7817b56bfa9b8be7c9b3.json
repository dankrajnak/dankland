{"ast":null,"code":"/**\n * *Bad name, I know.*  This method makes it possible\n * to 'join' together the easing of various things.  It was\n * initially designed to help ease cards off of a card deck.\n *\n * For example, let's say you have three cards sitting on the deck.\n * You want to ease the first, then the second, and finally the third\n * off of the deck.  The second should move some time after the first,\n * the third after the second.  Let's say that you want to have a function\n * to which you provide one number indicating the progress through the animation\n * and an index indicating a card and you want to get the position of that card.\n *\n * This function does that, but everything is normalized.  Provide a the number\n * of things you'd like to ease, a period (if 0 then all items will move at the same\n * time, 1, all items will move directly after the previous has finished, etc.), and\n * an easing function.  This function will return a range and the function mentioned\n * above which takes in a progress number (between 0 and 1) and an index.   The range is helpful to selectively\n * make animations slower which have a larger period or more elements.\n *\n * @param {number} numThings - number of things to ease\n * @param {number} period - if 0 things will move together, if 1 will move right after eachother, .5 will move halfway, etc.\n * @param {function} easeFunction - function which takes in a number between 0 and 1\n *  and outputs another number between 0 and 1.\n * @returns {[number, function, function]} the range, a function which inputs a progress number\n * and an index and outputs the value of the thing with that index for that progress number, and a\n * function which takes an index and returns the place in the range that index starts to be eased.\n */\nconst stepEaser = (numStages, period = 1, easeFunction = x => x) => {\n  // Figure out when the last stage will go and add one to it.\n  const length = (numStages - 1) * period + 1;\n\n  const getValue = (progress, index) => {\n    const val = progress * length - index * period;\n\n    if (val < 0) {\n      return 0;\n    }\n\n    if (val > 1) {\n      return 1;\n    }\n\n    return easeFunction(val);\n  };\n\n  const getEaseStart = index => index * period / length;\n\n  return [getValue, getEaseStart];\n};\n\nexport const mappedStepEaser = (inputFrom, inputTo, outputFrom, outputTo) => (numStages, period = 1, easeFunction = x => x) => {\n  const inputMap = val => (val - inputFrom) / (inputTo - inputFrom);\n\n  const outputMap = val => val * (outputTo - outputFrom) + outputFrom;\n\n  const inputMapInverse = val => val * (inputTo - inputFrom) + inputFrom;\n\n  const [getValue, getPosition] = stepEaser(numStages, period, easeFunction);\n  return [(progress, index) => outputMap(getValue(inputMap(progress), index)), index => inputMapInverse(getPosition(index))];\n};\nexport default stepEaser;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/EaseStep/EaseStep.service.ts"],"names":["stepEaser","numStages","period","easeFunction","x","length","getValue","progress","index","val","getEaseStart","mappedStepEaser","inputFrom","inputTo","outputFrom","outputTo","inputMap","outputMap","inputMapInverse","getPosition"],"mappings":"AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,MAAMA,SAAwB,GAAG,CAC/BC,SAD+B,EAE/BC,MAAM,GAAG,CAFsB,EAG/BC,YAAY,GAAGC,CAAC,IAAIA,CAHW,KAI5B;AACH;AACA,QAAMC,MAAM,GAAG,CAACJ,SAAS,GAAG,CAAb,IAAkBC,MAAlB,GAA2B,CAA1C;;AACA,QAAMI,QAAQ,GAAG,CAACC,QAAD,EAAmBC,KAAnB,KAAqC;AACpD,UAAMC,GAAG,GAAGF,QAAQ,GAAGF,MAAX,GAAoBG,KAAK,GAAGN,MAAxC;;AACA,QAAIO,GAAG,GAAG,CAAV,EAAa;AACX,aAAO,CAAP;AACD;;AACD,QAAIA,GAAG,GAAG,CAAV,EAAa;AACX,aAAO,CAAP;AACD;;AACD,WAAON,YAAY,CAACM,GAAD,CAAnB;AACD,GATD;;AAUA,QAAMC,YAAY,GAAIF,KAAD,IAAoBA,KAAK,GAAGN,MAAT,GAAmBG,MAA3D;;AACA,SAAO,CAACC,QAAD,EAAWI,YAAX,CAAP;AACD,CAnBD;;AAqBA,OAAO,MAAMC,eAAe,GAAG,CAC7BC,SAD6B,EAE7BC,OAF6B,EAG7BC,UAH6B,EAI7BC,QAJ6B,KAKX,CAClBd,SADkB,EAElBC,MAAM,GAAG,CAFS,EAGlBC,YAAY,GAAIC,CAAD,IAAeA,CAHZ,KAIf;AACH,QAAMY,QAAQ,GAAIP,GAAD,IAAiB,CAACA,GAAG,GAAGG,SAAP,KAAqBC,OAAO,GAAGD,SAA/B,CAAlC;;AAEA,QAAMK,SAAS,GAAIR,GAAD,IAAiBA,GAAG,IAAIM,QAAQ,GAAGD,UAAf,CAAH,GAAgCA,UAAnE;;AAEA,QAAMI,eAAe,GAAIT,GAAD,IACtBA,GAAG,IAAII,OAAO,GAAGD,SAAd,CAAH,GAA8BA,SADhC;;AAGA,QAAM,CAACN,QAAD,EAAWa,WAAX,IAA0BnB,SAAS,CAACC,SAAD,EAAYC,MAAZ,EAAoBC,YAApB,CAAzC;AAEA,SAAO,CACL,CAACI,QAAD,EAAmBC,KAAnB,KACES,SAAS,CAACX,QAAQ,CAACU,QAAQ,CAACT,QAAD,CAAT,EAAqBC,KAArB,CAAT,CAFN,EAGJA,KAAD,IAAmBU,eAAe,CAACC,WAAW,CAACX,KAAD,CAAZ,CAH7B,CAAP;AAKD,CAxBM;AA0BP,eAAeR,SAAf","sourcesContent":["type StepEaserType = (\n  numStages: number,\n  period?: number,\n  easeFunction?: (x0: number) => number\n) => [(progress: number, index: number) => number, (index: number) => number];\n/**\n * *Bad name, I know.*  This method makes it possible\n * to 'join' together the easing of various things.  It was\n * initially designed to help ease cards off of a card deck.\n *\n * For example, let's say you have three cards sitting on the deck.\n * You want to ease the first, then the second, and finally the third\n * off of the deck.  The second should move some time after the first,\n * the third after the second.  Let's say that you want to have a function\n * to which you provide one number indicating the progress through the animation\n * and an index indicating a card and you want to get the position of that card.\n *\n * This function does that, but everything is normalized.  Provide a the number\n * of things you'd like to ease, a period (if 0 then all items will move at the same\n * time, 1, all items will move directly after the previous has finished, etc.), and\n * an easing function.  This function will return a range and the function mentioned\n * above which takes in a progress number (between 0 and 1) and an index.   The range is helpful to selectively\n * make animations slower which have a larger period or more elements.\n *\n * @param {number} numThings - number of things to ease\n * @param {number} period - if 0 things will move together, if 1 will move right after eachother, .5 will move halfway, etc.\n * @param {function} easeFunction - function which takes in a number between 0 and 1\n *  and outputs another number between 0 and 1.\n * @returns {[number, function, function]} the range, a function which inputs a progress number\n * and an index and outputs the value of the thing with that index for that progress number, and a\n * function which takes an index and returns the place in the range that index starts to be eased.\n */\nconst stepEaser: StepEaserType = (\n  numStages,\n  period = 1,\n  easeFunction = x => x\n) => {\n  // Figure out when the last stage will go and add one to it.\n  const length = (numStages - 1) * period + 1;\n  const getValue = (progress: number, index: number) => {\n    const val = progress * length - index * period;\n    if (val < 0) {\n      return 0;\n    }\n    if (val > 1) {\n      return 1;\n    }\n    return easeFunction(val);\n  };\n  const getEaseStart = (index: number) => (index * period) / length;\n  return [getValue, getEaseStart];\n};\n\nexport const mappedStepEaser = (\n  inputFrom: number,\n  inputTo: number,\n  outputFrom: number,\n  outputTo: number\n): StepEaserType => (\n  numStages: number,\n  period = 1,\n  easeFunction = (x: number) => x\n) => {\n  const inputMap = (val: number) => (val - inputFrom) / (inputTo - inputFrom);\n\n  const outputMap = (val: number) => val * (outputTo - outputFrom) + outputFrom;\n\n  const inputMapInverse = (val: number) =>\n    val * (inputTo - inputFrom) + inputFrom;\n\n  const [getValue, getPosition] = stepEaser(numStages, period, easeFunction);\n\n  return [\n    (progress: number, index: number) =>\n      outputMap(getValue(inputMap(progress), index)),\n    (index: number) => inputMapInverse(getPosition(index)),\n  ];\n};\n\nexport default stepEaser;\n"]},"metadata":{},"sourceType":"module"}