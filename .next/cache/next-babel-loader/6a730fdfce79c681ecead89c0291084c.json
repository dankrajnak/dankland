{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\n\n/**\n * *Bad name, I know.*  This method makes it possible\n * to 'join' together the easing of various things.  It was\n * initially designed to help ease cards off of a card deck.\n *\n * For example, let's say you have three cards sitting on the deck.\n * You want to ease the first, then the second, and finally the third\n * off of the deck.  The second should move some time after the first,\n * the third after the second.  Let's say that you want to have a function\n * to which you provide one number indicating the progress through the animation\n * and an index indicating a card and you want to get the position of that card.\n *\n * This function does that, but everything is normalized.  Provide a the number\n * of things you'd like to ease, a period (if 0 then all items will move at the same\n * time, 1, all items will move directly after the previous has finished, etc.), and\n * an easing function.  This function will return a range and the function mentioned\n * above which takes in a progress number (between 0 and 1) and an index.   The range is helpful to selectively\n * make animations slower which have a larger period or more elements.\n *\n * @param {number} numThings - number of things to ease\n * @param {number} period - if 0 things will move together, if 1 will move right after eachother, .5 will move halfway, etc.\n * @param {function} easeFunction - function which takes in a number between 0 and 1\n *  and outputs another number between 0 and 1.\n * @returns {[number, function, function]} the range, a function which inputs a progress number\n * and an index and outputs the value of the thing with that index for that progress number, and a\n * function which takes an index and returns the place in the range that index starts to be eased.\n */\nvar stepEaser = function stepEaser(numStages) {\n  var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var easeFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (x) {\n    return x;\n  };\n  // Figure out when the last stage will go and add one to it.\n  var length = (numStages - 1) * period + 1;\n\n  var getValue = function getValue(progress, index) {\n    var val = progress * length - index * period;\n\n    if (val < 0) {\n      return 0;\n    }\n\n    if (val > 1) {\n      return 1;\n    }\n\n    return easeFunction(val);\n  };\n\n  var getEaseStart = function getEaseStart(index) {\n    return index * period / length;\n  };\n\n  return [getValue, getEaseStart];\n};\n\nexport var mappedStepEaser = function mappedStepEaser(inputFrom, inputTo, outputFrom, outputTo) {\n  return function (numStages) {\n    var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var easeFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (x) {\n      return x;\n    };\n\n    var inputMap = function inputMap(val) {\n      return (val - inputFrom) / (inputTo - inputFrom);\n    };\n\n    var outputMap = function outputMap(val) {\n      return val * (outputTo - outputFrom) + outputFrom;\n    };\n\n    var inputMapInverse = function inputMapInverse(val) {\n      return val * (inputTo - inputFrom) + inputFrom;\n    };\n\n    var _stepEaser = stepEaser(numStages, period, easeFunction),\n        _stepEaser2 = _slicedToArray(_stepEaser, 2),\n        getValue = _stepEaser2[0],\n        getPosition = _stepEaser2[1];\n\n    return [function (progress, index) {\n      return outputMap(getValue(inputMap(progress), index));\n    }, function (index) {\n      return inputMapInverse(getPosition(index));\n    }];\n  };\n};\nexport default stepEaser;","map":null,"metadata":{},"sourceType":"module"}