{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport Link from \"next/link\";\nimport useFullScreen from \"../../../Hooks/useFullScreen\";\nimport useScrollAmount from \"../../../Hooks/useScrollAmount\";\nimport CardDeck from \"./CardDeck/CardDeck\";\nconst ScrollMessage = styled.div.attrs(props => ({\n  style: {\n    opacity: props.opacity\n  }\n}))`\n  position: fixed;\n  bottom: 20px;\n  width: 100%;\n  text-align: center;\n  font-size: small;\n  color: #aaa;\n  z-index: 5000;\n`;\nconst AboutContainer = styled.div`\n  position: fixed;\n  top: 8%;\n  left: 8%;\n  width: 100%;\n  a {\n    text-decoration: none;\n    color: #222;\n    &:hover {\n      border-bottom: solid 1px #222;\n    }\n  }\n`;\n/**\n * Pages are represented as cards on a deck. As the user scrolls the cards roll off the deck\n * offscreen.  Known to be a little buggy on iphones.\n */\n\nconst CardMenu = ({\n  routeProps,\n  cards\n}) => {\n  const [width, height, flash] = useFullScreen();\n  const cardWidth = React.useMemo(() => Math.min(500, width * 0.9), [width]);\n  const cardHeight = React.useMemo(() => Math.min(500, height * 0.7), [height]);\n  const cardsWithDimensions = React.useMemo(() => cards.map(card => _objectSpread({}, card, {\n    background: __jsx(card.background, {\n      width: cardWidth,\n      height: cardHeight\n    })\n  })), [cardHeight, cardWidth, cards]);\n  const scrollToCard = React.useMemo(() => {\n    if (routeProps.location && routeProps.location.state && routeProps.location.state.prevPath) {\n      const prevLocation = routeProps.location.state.prevPath;\n      const index = cards.findIndex(card => card.link === prevLocation);\n      return index === -1 ? null : index;\n    }\n\n    return null;\n  }, [cards, routeProps.location]);\n  const scroll = useScrollAmount();\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(React.Fragment, null, __jsx(AboutContainer, null, __jsx(Link, {\n    href: \"/about\"\n  }, \"About\")), __jsx(CardDeck, {\n    cards: cardsWithDimensions,\n    width: width,\n    cardsWidth: cardWidth,\n    cardsHeight: cardHeight,\n    scrollToCard: scrollToCard\n  }), __jsx(ScrollMessage, {\n    opacity: (1 - scroll / height) * 2 || 0\n  }, \"Scroll Up\"));\n};\n\nexport default CardMenu;","map":null,"metadata":{},"sourceType":"module"}