{"ast":null,"code":"/**\n * Ok this might be a little confusing, but this type is a function that takes in a function f(x) where x is a Vector.\n * f returns a vector.  The function returns another function which takes in x and h and returns a vector.\n *\n * f(x) is a function in the form x' = f(x).  In other words, given a vector, it returns\n * the change (derivative) of that vector at that moment.  So, at time n, (x_n)' = f(x_n).  The method below returns a\n * function of the form x_(n+h) = g(x_n, h).  Notice that it's not the change in x, it's the actual value.\n *\n */\nconst multV = (vector, n) => vector.map(value => value * n);\n\nconst vplusV = (vector, vectorb) => vector.map((x, i) => x + (vectorb.get(i) || 0));\n\nexport const RungeKutta = f => (x, h) => {\n  const a = f(x);\n  const b = f(vplusV(x, multV(a, h / 2)));\n  const c = f(vplusV(x, multV(b, h / 2)));\n  const d = f(vplusV(x, multV(c, h))); // This next line is really confusing, but it amounts to\n  // x + h/6 * (a + 2b + 2c + d)\n\n  return vplusV(x, multV(vplusV(vplusV(vplusV(a, multV(b, 2)), multV(c, 2)), d), h / 6));\n};\nexport default RungeKutta;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/RungeKutta/RungeKutta.service.ts"],"names":["multV","vector","n","map","value","vplusV","vectorb","x","i","get","RungeKutta","f","h","a","b","c","d"],"mappings":"AAIA;;;;;;;;;AAaA,MAAMA,KAAK,GAAG,CAACC,MAAD,EAAsBC,CAAtB,KACZD,MAAM,CAACE,GAAP,CAAWC,KAAK,IAAIA,KAAK,GAAGF,CAA5B,CADF;;AAGA,MAAMG,MAAM,GAAG,CAACJ,MAAD,EAAsBK,OAAtB,KACbL,MAAM,CAACE,GAAP,CAAW,CAACI,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAID,OAAO,CAACG,GAAR,CAAYD,CAAZ,KAAkB,CAAtB,CAAtB,CADF;;AAGA,OAAO,MAAME,UAA+B,GAAGC,CAAC,IAAI,CAACJ,CAAD,EAAIK,CAAJ,KAAU;AAC5D,QAAMC,CAAc,GAAGF,CAAC,CAACJ,CAAD,CAAxB;AACA,QAAMO,CAAc,GAAGH,CAAC,CAACN,MAAM,CAACE,CAAD,EAAIP,KAAK,CAACa,CAAD,EAAID,CAAC,GAAG,CAAR,CAAT,CAAP,CAAxB;AACA,QAAMG,CAAc,GAAGJ,CAAC,CAACN,MAAM,CAACE,CAAD,EAAIP,KAAK,CAACc,CAAD,EAAIF,CAAC,GAAG,CAAR,CAAT,CAAP,CAAxB;AACA,QAAMI,CAAc,GAAGL,CAAC,CAACN,MAAM,CAACE,CAAD,EAAIP,KAAK,CAACe,CAAD,EAAIH,CAAJ,CAAT,CAAP,CAAxB,CAJ4D,CAK5D;AACA;;AACA,SAAOP,MAAM,CACXE,CADW,EAEXP,KAAK,CAACK,MAAM,CAACA,MAAM,CAACA,MAAM,CAACQ,CAAD,EAAIb,KAAK,CAACc,CAAD,EAAI,CAAJ,CAAT,CAAP,EAAyBd,KAAK,CAACe,CAAD,EAAI,CAAJ,CAA9B,CAAP,EAA8CC,CAA9C,CAAP,EAAyDJ,CAAC,GAAG,CAA7D,CAFM,CAAb;AAID,CAXM;AAaP,eAAeF,UAAf","sourcesContent":["import { Map } from \"immutable\";\n\nexport type Vector<K> = Map<K, number>;\n\n/**\n * Ok this might be a little confusing, but this type is a function that takes in a function f(x) where x is a Vector.\n * f returns a vector.  The function returns another function which takes in x and h and returns a vector.\n *\n * f(x) is a function in the form x' = f(x).  In other words, given a vector, it returns\n * the change (derivative) of that vector at that moment.  So, at time n, (x_n)' = f(x_n).  The method below returns a\n * function of the form x_(n+h) = g(x_n, h).  Notice that it's not the change in x, it's the actual value.\n *\n */\nexport type RungeKuttaType<K> = (\n  f: (x: Vector<K>) => Vector<K>\n) => (x: Vector<K>, h: number) => Vector<K>;\n\nconst multV = (vector: Vector<any>, n: number): Vector<any> =>\n  vector.map(value => value * n);\n\nconst vplusV = (vector: Vector<any>, vectorb: Vector<any>): Vector<any> =>\n  vector.map((x, i) => x + (vectorb.get(i) || 0));\n\nexport const RungeKutta: RungeKuttaType<any> = f => (x, h) => {\n  const a: Vector<any> = f(x);\n  const b: Vector<any> = f(vplusV(x, multV(a, h / 2)));\n  const c: Vector<any> = f(vplusV(x, multV(b, h / 2)));\n  const d: Vector<any> = f(vplusV(x, multV(c, h)));\n  // This next line is really confusing, but it amounts to\n  // x + h/6 * (a + 2b + 2c + d)\n  return vplusV(\n    x,\n    multV(vplusV(vplusV(vplusV(a, multV(b, 2)), multV(c, 2)), d), h / 6)\n  );\n};\n\nexport default RungeKutta;\n"]},"metadata":{},"sourceType":"module"}