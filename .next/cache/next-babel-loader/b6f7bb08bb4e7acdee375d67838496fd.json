{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from \"react\";\nimport MenuLayout from \"../View/Layout/MenuLayout\";\nimport Vector2d from \"../Domain/Vector/Vector2d\";\nimport useFullScreen from \"../View/Hooks/useFullScreen\";\nimport TypeBox from \"../View/PageComponents/JustSomeThought/TypeBox\";\nimport LongText from \"../View/PageComponents/JustSomeThought/LongText\";\nimport SEO from \"../View/Utility/seo\";\nvar TheThoughts = [\"It still comes back to you\", \"Alone and being here, not new\", \"Still want runaway rules and nothing to pursue\", \"Still want that all talk and just do\", \"I wanna be like shoes, slip me on and just groove\", \"Forget those nights that include you\", \"Jump in, swirl around, just move\", \"I keep trying to improve\", \"Can't do anything, just lose\", \"Can't listen to that song we used to\", \"I'm just trying to conclude something I can pack up and move to\", \"Get out of that place you just blew through\", \"Prove to myself I can move too\", \"Or find myself on that middle-aged accrue\", \"Find something on view I can booze to\", \"Find some friends, just a few\", \"Find a guy almost like you\", \"Watch me get up and make something new\", \"Watch me never worry about seeing you\"];\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case \"ADD_ELEMENT\":\n      // Don't add another element if we're at max, or if this element is already included\n      if (state.elements.length >= state.maxElements || state.nextKey > state.numElementsBeforeWhite) {\n        return state;\n      }\n\n      if (state.elements.find(function (elm) {\n        return elm.key === action.payload.key;\n      })) {\n        throw new Error(\"Element with key \".concat(action.payload.key, \" already added\"));\n      }\n\n      return _objectSpread({}, state, {\n        elements: state.elements.concat([action.payload]),\n        nextKey: state.nextKey + 1\n      });\n\n    case \"REMOVE_ELEMENT\":\n      return _objectSpread({}, state, {\n        elements: state.elements.filter(function (elm) {\n          return elm.key !== action.payload;\n        })\n      });\n\n    case \"SET_TIMEOUT\":\n      if (action.payload < 0) {\n        throw new Error(\"Tried to set timeout to value less than 0 -- \".concat(action.payload));\n      }\n\n      return _objectSpread({}, state, {\n        timeOut: action.payload\n      });\n\n    case \"NUDGE_MAX_ELEMENTS\":\n      console.log(\"New max elements\", state.maxElements + action.payload);\n      return _objectSpread({}, state, {\n        maxElements: Math.max(0, state.maxElements + action.payload)\n      });\n\n    default:\n      return state;\n  }\n};\n\nvar JustSomeThoughts = function JustSomeThoughts() {\n  var _React$useReducer = React.useReducer(reducer, {\n    maxElements: 1,\n    numElementsBeforeWhite: 100,\n    elements: [],\n    nextKey: 0,\n    timeOut: 2000\n  }),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      state = _React$useReducer2[0],\n      dispatch = _React$useReducer2[1];\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      showLongText = _React$useState2[0],\n      setShowLongText = _React$useState2[1];\n\n  var _useFullScreen = useFullScreen(),\n      _useFullScreen2 = _slicedToArray(_useFullScreen, 3),\n      width = _useFullScreen2[0],\n      height = _useFullScreen2[1],\n      flash = _useFullScreen2[2];\n\n  var maxElementsTimeout = React.useRef(20);\n  React.useEffect(function () {\n    //Periodically increase max elements.\n    var interval = setInterval(function () {\n      dispatch({\n        type: \"NUDGE_MAX_ELEMENTS\",\n        payload: 1\n      });\n      maxElementsTimeout.current = Math.max(10, maxElementsTimeout.current - 2);\n    }, maxElementsTimeout.current * 1000);\n    return function () {\n      return clearInterval(interval);\n    };\n  }, []);\n  React.useEffect(function () {\n    if (state.nextKey > state.numElementsBeforeWhite) {\n      return;\n    }\n\n    var timeout = setTimeout(function () {\n      var minTextWidth = 200;\n      var textWidth = minTextWidth + Math.random() * Math.min(500, width - minTextWidth);\n      var position = new Vector2d(Math.random() * (width - textWidth), Math.random() * height - 20);\n      var textToType = TheThoughts[state.nextKey % TheThoughts.length];\n      dispatch({\n        type: \"ADD_ELEMENT\",\n        payload: {\n          key: state.nextKey,\n          component: __jsx(TypeBox, {\n            key: state.nextKey,\n            textToType: textToType,\n            width: textWidth,\n            color: \"rgba(0,0,0, \".concat(Math.max(0, 1 - state.nextKey / state.numElementsBeforeWhite), \")\"),\n            pos: position,\n            unType: true,\n            onFinish: function onFinish() {\n              return dispatch({\n                type: \"REMOVE_ELEMENT\",\n                payload: state.nextKey\n              });\n            }\n          })\n        }\n      });\n    }, state.timeOut);\n    return function () {\n      clearTimeout(timeout);\n    };\n  }, [height, state.elements, state.maxElements, state.nextKey, state.numElementsBeforeWhite, state.timeOut, width]);\n  React.useEffect(function () {\n    var timeout = setTimeout(function () {\n      setShowLongText(true);\n    }, 25000);\n    return function () {\n      clearTimeout(timeout);\n    };\n  }, []);\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(MenuLayout, {\n    color: \"black\"\n  }, __jsx(SEO, {\n    title: \"Just Some Thought\",\n    keywords: [\"poetry\", \"new media\", \"thought\"]\n  }), showLongText && __jsx(LongText, null), state.elements.map(function (elm) {\n    return elm.component;\n  }));\n};\n\nexport default JustSomeThoughts;","map":null,"metadata":{},"sourceType":"module"}