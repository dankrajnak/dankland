{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime-corejs2/helpers/esm/taggedTemplateLiteral\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nvar __jsx = React.createElement;\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n  position: fixed;\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  height: \", \"px;\\n  width: 100%;\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport useScrollAmount from \"../../../../Hooks/useScrollAmount\";\nimport Card from \"../Card/Card\";\nimport useFullScreen from \"../../../../Hooks/useFullScreen\";\nimport { mappedStepEaser } from \"../../../../../Services/EaseStep/EaseStep.service\";\nimport EasingFunctions from \"../../../../../Services/Ease/Ease.service\";\nimport Link from \"next/link\";\nimport useSafeWindow from \"../../../../Hooks/useSafeWindow\"; // TODO find a better way to do this.\n// @ts-ignore\n\nvar _ref = {},\n    width = _ref.width,\n    height = _ref.height,\n    CardPropsSubset = _objectWithoutProperties(_ref, [\"width\", \"height\"]);\n\nvar CardDeckHolder = styled.div(_templateObject(), function (props) {\n  return props.height;\n});\nvar CardHolder = styled.div.attrs(function (props) {\n  return {\n    style: {\n      transform: \"translate(\".concat(props.dx, \"px, \").concat(props.dy, \"px)\"),\n      zIndex: 2000 - props.order\n    }\n  };\n})(_templateObject2());\nvar PERIOD = 0.4;\nvar EASING_FUNCTION = EasingFunctions.easeInOutQuart;\n/**\n * Creates a scrollable Card Deck.\n * @param {Props} props\n */\n\nvar CardDeck = function CardDeck(props) {\n  var scroll = useScrollAmount(true);\n\n  var _useSafeWindow = useSafeWindow(),\n      _useSafeWindow2 = _slicedToArray(_useSafeWindow, 1),\n      window = _useSafeWindow2[0];\n\n  var _useFullScreen = useFullScreen(),\n      _useFullScreen2 = _slicedToArray(_useFullScreen, 3),\n      windowWidth = _useFullScreen2[0],\n      windowHeight = _useFullScreen2[1],\n      flash = _useFullScreen2[2]; // This is the position on the screen the deck sits.  It's a computed value based on the windowWidth.\n\n\n  var deckPosition = React.useMemo(function () {\n    return (windowWidth - props.cardsWidth) / 2;\n  }, [props.cardsWidth, windowWidth]);\n  var scrollDemap = React.useMemo(function () {\n    return function (val) {\n      return deckPosition - windowWidth * val;\n    };\n  }, [deckPosition, windowWidth]);\n  var scrollLength = windowHeight * 5;\n  var cardPositionStart = deckPosition;\n  var cardPositionEnd = -props.cardsWidth; // Memoize stepEaser to only generate range and getPosition when the cards length changes.\n\n  var _React$useMemo = React.useMemo(function () {\n    return mappedStepEaser(0, scrollLength, cardPositionStart, cardPositionEnd)(props.cards.length - 1, PERIOD, EASING_FUNCTION);\n  }, [cardPositionEnd, cardPositionStart, props.cards.length, scrollLength]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      getPosition = _React$useMemo2[0],\n      getEaseStart = _React$useMemo2[1]; // Move to the saved scroll position when this component renders\n\n\n  React.useLayoutEffect(function () {\n    var timeout;\n\n    if (window) {\n      if (props.scrollToCard) {\n        //Ok, this is hacky, but unless we wait a few milliseconds,\n        // the screen doesn't have time to render and we don't scroll anywhere.\n        // As far as I can tell for now, there's no way to listen for when all the cards have been rendered\n        setTimeout(function () {\n          if (props.scrollToCard) {\n            window.scrollTo(0, // Add a little to the index to give make sure the card on top has moved off of the card below\n            // TODO this should take the easing function into account.\n            getEaseStart(props.scrollToCard + 2 / props.cards.length));\n          }\n        }, 15);\n      }\n    }\n\n    return function () {\n      clearTimeout(timeout);\n    };\n  }, [getEaseStart, props.cards.length, props.scrollToCard, window]);\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(CardDeckHolder, {\n    height: scrollLength + windowHeight\n  }, props.cards.map(function (card, i) {\n    // Only draw cards when the card above it has moved and it's on screen.\n    var nextCardPosition = i !== props.cards.length - 1 ? getPosition(scroll, i + 1) : cardPositionStart;\n    var currentCardPosition = getPosition(scroll, i);\n    var prevCardPosition = i !== 0 ? getPosition(scroll, i - 1) : cardPositionEnd;\n    var shouldNotDrawCard = currentCardPosition === nextCardPosition && currentCardPosition !== deckPosition || prevCardPosition === cardPositionStart;\n    return __jsx(Link, {\n      href: card.link,\n      key: i,\n      className: \"card-deck-card-link\"\n    }, __jsx(CardHolder, {\n      dx: i === props.cards.length - 1 ? cardPositionStart : currentCardPosition,\n      dy: (windowHeight - props.cardsHeight) / 2,\n      order: i\n    }, !shouldNotDrawCard && __jsx(Card, _extends({}, card, {\n      width: props.cardsWidth,\n      height: props.cardsHeight,\n      shadowAmount: i === props.cards.length - 1 ? 0 : scrollDemap(getPosition(scroll, i))\n    }))));\n  }));\n};\n\nexport default CardDeck;","map":null,"metadata":{},"sourceType":"module"}