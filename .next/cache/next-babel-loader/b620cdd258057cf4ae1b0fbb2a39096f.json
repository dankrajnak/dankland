{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Private statics\nconst calcMagnitude = v => Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));\n\nconst INVERSE_SQUARE_ROOT_TWO = 1 / Math.sqrt(2);\nexport default class Vector2d {\n  constructor(x, y) {\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  get magnitudeSquared() {\n    return Math.pow(this.x, 2) + Math.pow(this.y, 2);\n  }\n\n  get magnitude() {\n    return calcMagnitude(this);\n  }\n\n  get normalized() {\n    const magnitude = calcMagnitude(this);\n    return new Vector2d(this.x / magnitude, this.y / magnitude);\n  }\n\n  get abs() {\n    return new Vector2d(Math.abs(this.x), Math.abs(this.y));\n  }\n  /**\n   * More info here: https://www.h3xed.com/programming/fast-unit-vector-calculation-for-2d-games\n   */\n\n\n  get approxUnit() {\n    if (!this.x) {\n      if (!this.y) {\n        return new Vector2d(0, 0);\n      } else {\n        return new Vector2d(0, 1);\n      }\n    } else if (!this.y) {\n      return new Vector2d(1, 0);\n    }\n\n    const absVector = this.abs;\n    let ratio = 1 / Math.max(absVector.x, absVector.y);\n    ratio *= (1 - INVERSE_SQUARE_ROOT_TWO) * 10 - (absVector.x + absVector.y) * ratio * (1 - INVERSE_SQUARE_ROOT_TWO);\n    return new Vector2d(this.x * ratio, this.y * ratio);\n  }\n\n  plus(b) {\n    return new Vector2d(b.x + this.x, b.y + this.y);\n  }\n\n  minus(b) {\n    return new Vector2d(this.x - b.x, this.y - b.y);\n  }\n\n  dot(b) {\n    return this.x * b.x + this.y * b.y;\n  }\n\n  times(scalar) {\n    return new Vector2d(this.x * scalar, this.y * scalar);\n  }\n\n  scaleTo(magnitude) {\n    return this.normalized.times(magnitude);\n  }\n\n  transform(matrix) {\n    return new Vector2d(this.x * matrix[0] + this.y * matrix[1], this.x * matrix[2] + this.y * matrix[3]);\n  }\n\n  squaredDistanceTo(b) {\n    return Math.pow(this.x - b.x, 2) + Math.pow(this.y - b.y, 2);\n  }\n\n  distanceTo(b) {\n    return Math.sqrt(this.squaredDistanceTo(b));\n  }\n\n  clone() {\n    return new Vector2d(this.x, this.y);\n  }\n\n}","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Domain/Vector/Vector2d.ts"],"names":["calcMagnitude","v","Math","sqrt","pow","x","y","INVERSE_SQUARE_ROOT_TWO","Vector2d","constructor","magnitudeSquared","magnitude","normalized","abs","approxUnit","absVector","ratio","max","plus","b","minus","dot","times","scalar","scaleTo","transform","matrix","squaredDistanceTo","distanceTo","clone"],"mappings":"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","sourcesContent":["// Private statics\nconst calcMagnitude = (v: Vector2d): number =>\n  Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));\n\nconst INVERSE_SQUARE_ROOT_TWO = 1 / Math.sqrt(2);\n\nexport default class Vector2d {\n  public x: number;\n  public y: number;\n\n  public constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public get magnitudeSquared(): number {\n    return Math.pow(this.x, 2) + Math.pow(this.y, 2);\n  }\n\n  public get magnitude() {\n    return calcMagnitude(this);\n  }\n\n  public get normalized(): Vector2d {\n    const magnitude = calcMagnitude(this);\n    return new Vector2d(this.x / magnitude, this.y / magnitude);\n  }\n\n  public get abs(): Vector2d {\n    return new Vector2d(Math.abs(this.x), Math.abs(this.y));\n  }\n\n  /**\n   * More info here: https://www.h3xed.com/programming/fast-unit-vector-calculation-for-2d-games\n   */\n  public get approxUnit(): Vector2d {\n    if (!this.x) {\n      if (!this.y) {\n        return new Vector2d(0, 0);\n      } else {\n        return new Vector2d(0, 1);\n      }\n    } else if (!this.y) {\n      return new Vector2d(1, 0);\n    }\n    const absVector = this.abs;\n    let ratio = 1 / Math.max(absVector.x, absVector.y);\n\n    ratio *=\n      (1 - INVERSE_SQUARE_ROOT_TWO) * 10 -\n      (absVector.x + absVector.y) * ratio * (1 - INVERSE_SQUARE_ROOT_TWO);\n\n    return new Vector2d(this.x * ratio, this.y * ratio);\n  }\n\n  public plus(b: Vector2d): Vector2d {\n    return new Vector2d(b.x + this.x, b.y + this.y);\n  }\n\n  public minus(b: Vector2d): Vector2d {\n    return new Vector2d(this.x - b.x, this.y - b.y);\n  }\n  public dot(b: Vector2d): number {\n    return this.x * b.x + this.y * b.y;\n  }\n\n  public times(scalar: number): Vector2d {\n    return new Vector2d(this.x * scalar, this.y * scalar);\n  }\n\n  public scaleTo(magnitude: number): Vector2d {\n    return this.normalized.times(magnitude);\n  }\n\n  public transform(matrix: [number, number, number, number]): Vector2d {\n    return new Vector2d(\n      this.x * matrix[0] + this.y * matrix[1],\n      this.x * matrix[2] + this.y * matrix[3]\n    );\n  }\n\n  public squaredDistanceTo(b: Vector2d): number {\n    return Math.pow(this.x - b.x, 2) + Math.pow(this.y - b.y, 2);\n  }\n\n  public distanceTo(b: Vector2d): number {\n    return Math.sqrt(this.squaredDistanceTo(b));\n  }\n\n  public clone(): Vector2d {\n    return new Vector2d(this.x, this.y);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}