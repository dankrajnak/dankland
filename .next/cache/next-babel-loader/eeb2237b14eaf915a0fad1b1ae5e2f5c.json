{"ast":null,"code":"import { Map } from \"immutable\";\nimport RungeKutta from \"../RungeKutta/RungeKutta.service\";\nexport const makePendulum = () => Map({\n  aMass: 100,\n  aLength: 50 + Math.random() * 80,\n  aAngle: Math.PI + Math.random() * 1 - 0.5,\n  aAngularVelocity: 0,\n  aAngAccel: 0,\n  bMass: 50,\n  bLength: 50,\n  bAngle: Math.random() * 6,\n  bAngularVelocity: 0,\n  bAngAccel: 0\n});\nconst GRAVITY = 9.8;\nconst SPEED = 0.1;\n/**\n * This system of equations has 4 variables\n * the angular velocity of a,\n * the angular velocity of b,\n * the angle of a,\n * the angle of b.\n *\n * So, we need to create a function which takes in those four variables, and calculates everything else from that.\n * Hopefully this won't be super confusing to future me, but this function takes in a pendulum, and returns a function\n * that does that.\n */\n\nconst getRungeKuttaFunctionForPendulum = p => v => {\n  // This is from a website. (https://www.myphysicslab.com/pendulum/double-pendulum-en.html)\n  // Also I realize that p. and v. look very similar which might make the following hard to debug / read\n  // (like it wasn't hard already)\n  // Sorry future me.\n  // Declare all the values I need so that I don't have to worry about whether their undefined.\n  const pAMass = p.get(\"aMass\") || 0;\n  const pBMass = p.get(\"bMass\") || 0;\n  const pALength = p.get(\"aLength\") || 0;\n  const pBLength = p.get(\"bLength\") || 0;\n  const vAngA = v.get(\"angA\") || 0;\n  const vAngB = v.get(\"angB\") || 0;\n  const vVelA = v.get(\"velA\") || 0;\n  const vVelB = v.get(\"velB\") || 0;\n  const angVelA = vVelA;\n  const angVelB = vVelB;\n  const angAccelA = (-GRAVITY * (2 * pAMass + pBMass) * Math.sin(vAngA) - pBMass * GRAVITY * Math.sin(vAngA - 2 * vAngB) - 2 * Math.sin(vAngA - vAngB) * pBMass * (Math.pow(vVelB, 2) * pBLength + Math.pow(vVelA, 2) * pALength * Math.cos(vAngA - vAngB))) / (pALength * (2 * pAMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n  const angAccelB = 2 * Math.sin(vAngA - vAngB) * (Math.pow(vVelA, 2) * pALength * (pAMass + pBMass) + GRAVITY * (pAMass + pBMass * Math.cos(vAngA + Math.pow(vVelB, 2) * pBLength * pBMass * Math.cos(vAngA - vAngB)))) / (pBLength * (2 * pBMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n  return Map({\n    velA: angAccelA,\n    velB: angAccelB,\n    angA: angVelA,\n    angB: angVelB\n  });\n};\n/**\n * Simulates chaotic pendulums utilizing the Runge-Katta algorithm\n */\n\n\nconst getNextPendulum = prevPendulum => {\n  // Ok, so the next few lines are going to get pretty complicated.\n  // Just bear with me, we'll make it through together.\n\n  /* This is really condensed.\n   * RungeKutta takes in a function of the form specified by the runge katta algorithm\n   * and returns a function which we can use to calculate the next state of a simulation\n   * after some time.  We then store the result of this next state in the map variable.\n   * after that, we return the previous pendulum with the populated with the values\n   * from this map variable (it's an immutable.js map, so we're not mutating anything)\n   */\n  const map = RungeKutta(getRungeKuttaFunctionForPendulum(prevPendulum))(Map({\n    angA: prevPendulum.get(\"aAngle\"),\n    angB: prevPendulum.get(\"bAngle\"),\n    velA: prevPendulum.get(\"aAngularVelocity\"),\n    velB: prevPendulum.get(\"bAngularVelocity\")\n  }), SPEED);\n  return prevPendulum.set(\"aAngle\", map.get(\"angA\") || 0).set(\"bAngle\", map.get(\"angB\") || 0).set(\"aAngularVelocity\", map.get(\"velA\") || 0).set(\"bAngularVelocity\", map.get(\"velB\") || 0);\n};\n\nexport default getNextPendulum;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/DoublePendulum/DoublePendulum.service.ts"],"names":["Map","RungeKutta","makePendulum","aMass","aLength","Math","random","aAngle","PI","aAngularVelocity","aAngAccel","bMass","bLength","bAngle","bAngularVelocity","bAngAccel","GRAVITY","SPEED","getRungeKuttaFunctionForPendulum","p","v","pAMass","get","pBMass","pALength","pBLength","vAngA","vAngB","vVelA","vVelB","angVelA","angVelB","angAccelA","sin","pow","cos","angAccelB","velA","velB","angA","angB","getNextPendulum","prevPendulum","map","set"],"mappings":"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","sourcesContent":["import { Map } from \"immutable\";\n\nimport RungeKutta, { Vector } from \"../RungeKutta/RungeKutta.service\";\n\nexport type PendulumVector = Map<\n  | \"aMass\"\n  | \"aLength\"\n  | \"aAngle\"\n  | \"aAngularVelocity\"\n  | \"aAngAccel\"\n  | \"bMass\"\n  | \"bLength\"\n  | \"bAngle\"\n  | \"bAngularVelocity\"\n  | \"bAngAccel\",\n  number\n>;\n\ntype RungeKuttaIngestion = Vector<\"velA\" | \"velB\" | \"angA\" | \"angB\">;\n\nexport const makePendulum = (): PendulumVector =>\n  Map({\n    aMass: 100,\n    aLength: 50 + Math.random() * 80,\n    aAngle: Math.PI + Math.random() * 1 - 0.5,\n    aAngularVelocity: 0,\n    aAngAccel: 0,\n    bMass: 50,\n    bLength: 50,\n    bAngle: Math.random() * 6,\n    bAngularVelocity: 0,\n    bAngAccel: 0,\n  }) as PendulumVector;\n\nconst GRAVITY = 9.8;\nconst SPEED = 0.1;\n\n/**\n * This system of equations has 4 variables\n * the angular velocity of a,\n * the angular velocity of b,\n * the angle of a,\n * the angle of b.\n *\n * So, we need to create a function which takes in those four variables, and calculates everything else from that.\n * Hopefully this won't be super confusing to future me, but this function takes in a pendulum, and returns a function\n * that does that.\n */\ntype FunctionForPendulum = (\n  p: PendulumVector\n) => (v: RungeKuttaIngestion) => RungeKuttaIngestion;\n\nconst getRungeKuttaFunctionForPendulum: FunctionForPendulum = (\n  p: PendulumVector\n) => (v: RungeKuttaIngestion) => {\n  // This is from a website. (https://www.myphysicslab.com/pendulum/double-pendulum-en.html)\n  // Also I realize that p. and v. look very similar which might make the following hard to debug / read\n  // (like it wasn't hard already)\n  // Sorry future me.\n\n  // Declare all the values I need so that I don't have to worry about whether their undefined.\n  const pAMass = p.get(\"aMass\") || 0;\n  const pBMass = p.get(\"bMass\") || 0;\n  const pALength = p.get(\"aLength\") || 0;\n  const pBLength = p.get(\"bLength\") || 0;\n  const vAngA = v.get(\"angA\") || 0;\n  const vAngB = v.get(\"angB\") || 0;\n  const vVelA = v.get(\"velA\") || 0;\n  const vVelB = v.get(\"velB\") || 0;\n\n  const angVelA = vVelA;\n  const angVelB = vVelB;\n\n  const angAccelA =\n    (-GRAVITY * (2 * pAMass + pBMass) * Math.sin(vAngA) -\n      pBMass * GRAVITY * Math.sin(vAngA - 2 * vAngB) -\n      2 *\n        Math.sin(vAngA - vAngB) *\n        pBMass *\n        (Math.pow(vVelB, 2) * pBLength +\n          Math.pow(vVelA, 2) * pALength * Math.cos(vAngA - vAngB))) /\n    (pALength *\n      (2 * pAMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n\n  const angAccelB =\n    (2 *\n      Math.sin(vAngA - vAngB) *\n      (Math.pow(vVelA, 2) * pALength * (pAMass + pBMass) +\n        GRAVITY *\n          (pAMass +\n            pBMass *\n              Math.cos(\n                vAngA +\n                  Math.pow(vVelB, 2) *\n                    pBLength *\n                    pBMass *\n                    Math.cos(vAngA - vAngB)\n              )))) /\n    (pBLength *\n      (2 * pBMass + pBMass - pBMass * Math.cos(2 * vAngA - 2 * vAngB)));\n\n  return Map({\n    velA: angAccelA,\n    velB: angAccelB,\n    angA: angVelA,\n    angB: angVelB,\n  }) as RungeKuttaIngestion;\n};\n\n/**\n * Simulates chaotic pendulums utilizing the Runge-Katta algorithm\n */\nconst getNextPendulum = (prevPendulum: PendulumVector): PendulumVector => {\n  // Ok, so the next few lines are going to get pretty complicated.\n  // Just bear with me, we'll make it through together.\n\n  /* This is really condensed.\n   * RungeKutta takes in a function of the form specified by the runge katta algorithm\n   * and returns a function which we can use to calculate the next state of a simulation\n   * after some time.  We then store the result of this next state in the map variable.\n   * after that, we return the previous pendulum with the populated with the values\n   * from this map variable (it's an immutable.js map, so we're not mutating anything)\n   */\n  const map: RungeKuttaIngestion = RungeKutta(\n    getRungeKuttaFunctionForPendulum(prevPendulum)\n  )(\n    Map({\n      angA: prevPendulum.get(\"aAngle\"),\n      angB: prevPendulum.get(\"bAngle\"),\n      velA: prevPendulum.get(\"aAngularVelocity\"),\n      velB: prevPendulum.get(\"bAngularVelocity\"),\n    }) as RungeKuttaIngestion,\n    SPEED\n  );\n\n  return prevPendulum\n    .set(\"aAngle\", map.get(\"angA\") || 0)\n    .set(\"bAngle\", map.get(\"angB\") || 0)\n    .set(\"aAngularVelocity\", map.get(\"velA\") || 0)\n    .set(\"bAngularVelocity\", map.get(\"velB\") || 0);\n};\n\nexport default getNextPendulum;\n"]},"metadata":{},"sourceType":"module"}