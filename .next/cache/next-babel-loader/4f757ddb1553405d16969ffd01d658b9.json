{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from \"react\";\nimport TypeWriterService from \"../../../Services/TypeWriter/TypeWriter.service\";\n/**\n * A representation of a delayed state of the typed text.\n */\n\nexport var DEFAULT_TYPE_CONFIG = {\n  typeDelay: {\n    base: 100,\n    variance: 50\n  },\n  mistakeRealizeDelay: {\n    base: 250,\n    variance: 50\n  },\n  mistakeProbability: 0.02\n};\n/**\n * Type the provided text according to the type config.\n */\n\nexport var reducer = function reducer(state, action) {\n  switch (action.type) {\n    case \"TYPE_TEXT\":\n      var textToType = \"\";\n\n      if (state.sequence.length) {\n        // Get the value of the text once the sequence is completed.\n        // We should add the text provided to this text.\n        textToType = state.sequence[state.sequence.length - 1].text;\n      }\n\n      var typeSequence = []; // In the special case in which we're just typing an empty string, add a DelayNode\n      // to call the listener if there is one.\n\n      if (action.payload.text === \"\" && action.payload.listener) {\n        return _objectSpread({}, state, {\n          sequence: state.sequence.concat([{\n            text: textToType,\n            delay: 0,\n            listener: action.payload.listener\n          }])\n        });\n      } // Function for generating a the delay of typing a character.\n\n\n      var getTypeDelay = function getTypeDelay() {\n        return Math.max(0, action.payload.typeConfig.typeDelay.base + Math.random() * action.payload.typeConfig.typeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance);\n      }; // Function for generating the delay of realizing a mistake.\n\n\n      var getMistakeDelay = function getMistakeDelay() {\n        return Math.max(0, action.payload.typeConfig.mistakeRealizeDelay.base + Math.random() * action.payload.typeConfig.mistakeRealizeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance);\n      }; // For each character...\n\n\n      action.payload.text.split(\"\").forEach(function (_char, i) {\n        // Possibly make a mistake\n        if (Math.random() <= action.payload.typeConfig.mistakeProbability) {\n          //Type mistake character\n          typeSequence.push({\n            text: textToType + TypeWriterService.getMistakeCharacter(_char),\n            delay: getTypeDelay()\n          }); // Then erase it.\n\n          typeSequence.push({\n            text: textToType,\n            delay: getMistakeDelay()\n          });\n        } // The next text should include the next character\n\n\n        textToType += _char; // If this is the last node to add, add the listener to the node.\n\n        if (i === action.payload.text.length - 1 && action.payload.listener) {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay(),\n            listener: action.payload.listener\n          });\n        } else {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay()\n          });\n        }\n      });\n      return _objectSpread({}, state, {\n        sequence: state.sequence.concat(typeSequence)\n      });\n\n    case \"DELETE_ALL\":\n      //Don't do anything if the current value is empty\n      if (!state.currentValue.length) {\n        return state;\n      } //Immediately delete all characters.\n\n\n      var newSequence = state.currentValue.split(\"\").slice(0, state.currentValue.length - 1) // I.E. \"123\" -> [\"12\", \"1\", \"\"]\n      .reduce(function (sum, _char2) {\n        return [sum[0] + _char2].concat(sum);\n      }, [\"\"]) // Deletes take 10 miliseconds (this value is not configurable yet.)\n      .map(function (text) {\n        return {\n          text: text,\n          delay: 10\n        };\n      });\n      return _objectSpread({}, state, {\n        sequence: newSequence\n      });\n\n    case \"WAIT_FOR_NEXT_NODE\":\n      return _objectSpread({}, state, {\n        isWaiting: true\n      });\n\n    case \"TYPE_NODE\":\n      return {\n        currentValue: state.sequence[0].text,\n        sequence: state.sequence.slice(1),\n        isWaiting: false\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Types some characters.  It's pretty sick.\n *\n * @param initialText - the value of text will start with this value\n * @returns [currentValueOfText, setText, isIdle]\n */\nvar useTypeWriter = function useTypeWriter() {\n  var initialText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n  var _React$useReducer = React.useReducer(reducer, {\n    currentValue: initialText,\n    sequence: [],\n    isWaiting: false\n  }),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      state = _React$useReducer2[0],\n      dispatch = _React$useReducer2[1];\n\n  var nextNodeTimeout = React.useRef(null);\n  React.useEffect(function () {\n    if (state.isWaiting || !state.sequence.length) {\n      return;\n    }\n\n    var nextNode = state.sequence[0];\n    dispatch({\n      type: \"WAIT_FOR_NEXT_NODE\",\n      payload: null\n    });\n    nextNodeTimeout.current = setTimeout(function () {\n      dispatch({\n        type: \"TYPE_NODE\",\n        payload: null\n      });\n\n      if (nextNode.listener) {\n        nextNode.listener();\n      }\n    }, nextNode.delay);\n  }, [state]);\n  React.useEffect(function () {\n    return function () {\n      nextNodeTimeout.current !== null && clearTimeout(nextNodeTimeout.current);\n    };\n  }, []);\n  /**\n   * Use ref so this function can be used in effects and won't cause\n   * the effect to rerun after state changes.\n   */\n\n  var typeNextText = React.useRef(function (nextText, config) {\n    dispatch({\n      type: \"DELETE_ALL\",\n      payload: null\n    });\n\n    var typeTextPayload = _objectSpread({}, config, {\n      //If a config.typeConfig is provided set it to the type config, otherwise use the default\n      typeConfig: config && config.typeConfig || DEFAULT_TYPE_CONFIG,\n      text: nextText\n    });\n\n    dispatch({\n      type: \"TYPE_TEXT\",\n      payload: typeTextPayload\n    });\n  });\n  return [state.currentValue, typeNextText.current, state.sequence.length === 0];\n};\n\nexport default useTypeWriter;","map":null,"metadata":{},"sourceType":"module"}