{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport Square from \"../../Domain/Square/Square\";\n\nvar PerspectiveSquare =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Depth of perspective\n   */\n\n  /**\n   * Max front square moves away from the vanishPoint.\n   */\n  function PerspectiveSquare(square) {\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var maxSquareDisplacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n    _classCallCheck(this, PerspectiveSquare);\n\n    _defineProperty(this, \"depth\", void 0);\n\n    _defineProperty(this, \"maxSquareDisplacement\", void 0);\n\n    _defineProperty(this, \"_squareCenter\", void 0);\n\n    _defineProperty(this, \"_square\", void 0);\n\n    this._squareCenter = square.center;\n    this._square = square.clone();\n    this.depth = depth;\n    this.maxSquareDisplacement = maxSquareDisplacement;\n  }\n\n  _createClass(PerspectiveSquare, [{\n    key: \"getSquares\",\n    value: function getSquares(vanishPoint) {\n      // Calculate first square\n      var displacementVector = this._squareCenter.minus(vanishPoint);\n\n      if (displacementVector.magnitude > this.maxSquareDisplacement) {\n        displacementVector = displacementVector.scaleTo(this.maxSquareDisplacement);\n      }\n\n      var squareOne = new Square(this._square.width, this._square.position.plus(displacementVector)); // Calculate second square\n\n      var squareTwo;\n\n      if (vanishPoint.minus(squareOne.points.a).magnitude < this.depth) {\n        squareTwo = new Square(0, vanishPoint);\n      } else {\n        // Let's break out some fucking math. Alright.\n        // Offset is a vector reprsenting the change in position from squareOne to squareTwo.\n        var offset = vanishPoint.minus(squareOne.position).scaleTo(this.depth); // To get squareTwo's position, we add offset to squareOne.\n\n        var squareTwoPosition = offset.plus(squareOne.position); // Then let's calculate the width.  This might not be the most efficient, but\n        // we can use similar triangles and compare the distance from the top left point\n        // of squareA to the vanishing point to the distance between squareTwo's position\n        // and the vanishing point and use that ratio to determine the width given the width of squareOne\n\n        var vanishPointDistance = squareOne.position.minus(vanishPoint).magnitude;\n        var squareTwoWidth = squareOne.width * (vanishPointDistance - this.depth) / vanishPointDistance;\n        squareTwo = new Square(squareTwoWidth, squareTwoPosition);\n      }\n\n      return [squareOne, squareTwo];\n    }\n  }]);\n\n  return PerspectiveSquare;\n}();\n\nexport { PerspectiveSquare as default };","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/PerspectiveSquare/PerspectiveSquare.service.ts"],"names":["Square","PerspectiveSquare","square","depth","maxSquareDisplacement","_squareCenter","center","_square","clone","vanishPoint","displacementVector","minus","magnitude","scaleTo","squareOne","width","position","plus","squareTwo","points","a","offset","squareTwoPosition","vanishPointDistance","squareTwoWidth"],"mappings":";;;AAAA,OAAOA,MAAP,MAAmB,4BAAnB;;IAGqBC,iB;;;AACnB;;;;AAIA;;;AAQA,6BAAmBC,MAAnB,EAA4E;AAAA,QAAzCC,KAAyC,uEAAjC,GAAiC;AAAA,QAA5BC,qBAA4B,uEAAJ,EAAI;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAC1E,SAAKC,aAAL,GAAqBH,MAAM,CAACI,MAA5B;AAEA,SAAKC,OAAL,GAAeL,MAAM,CAACM,KAAP,EAAf;AAEA,SAAKL,KAAL,GAAaA,KAAb;AACA,SAAKC,qBAAL,GAA6BA,qBAA7B;AACD;;;;+BAEiBK,W,EAAyC;AACzD;AACA,UAAIC,kBAAkB,GAAG,KAAKL,aAAL,CAAmBM,KAAnB,CAAyBF,WAAzB,CAAzB;;AACA,UAAIC,kBAAkB,CAACE,SAAnB,GAA+B,KAAKR,qBAAxC,EAA+D;AAC7DM,QAAAA,kBAAkB,GAAGA,kBAAkB,CAACG,OAAnB,CACnB,KAAKT,qBADc,CAArB;AAGD;;AAED,UAAMU,SAAS,GAAG,IAAId,MAAJ,CAChB,KAAKO,OAAL,CAAaQ,KADG,EAEhB,KAAKR,OAAL,CAAaS,QAAb,CAAsBC,IAAtB,CAA2BP,kBAA3B,CAFgB,CAAlB,CATyD,CAczD;;AACA,UAAIQ,SAAJ;;AACA,UAAIT,WAAW,CAACE,KAAZ,CAAkBG,SAAS,CAACK,MAAV,CAAiBC,CAAnC,EAAsCR,SAAtC,GAAkD,KAAKT,KAA3D,EAAkE;AAChEe,QAAAA,SAAS,GAAG,IAAIlB,MAAJ,CAAW,CAAX,EAAcS,WAAd,CAAZ;AACD,OAFD,MAEO;AACL;AAEA;AACA,YAAMY,MAAM,GAAGZ,WAAW,CAACE,KAAZ,CAAkBG,SAAS,CAACE,QAA5B,EAAsCH,OAAtC,CAA8C,KAAKV,KAAnD,CAAf,CAJK,CAML;;AACA,YAAMmB,iBAAiB,GAAGD,MAAM,CAACJ,IAAP,CAAYH,SAAS,CAACE,QAAtB,CAA1B,CAPK,CASL;AACA;AACA;AACA;;AACA,YAAMO,mBAAmB,GAAGT,SAAS,CAACE,QAAV,CAAmBL,KAAnB,CAAyBF,WAAzB,EACzBG,SADH;AAGA,YAAMY,cAAc,GACjBV,SAAS,CAACC,KAAV,IAAmBQ,mBAAmB,GAAG,KAAKpB,KAA9C,CAAD,GACAoB,mBAFF;AAIAL,QAAAA,SAAS,GAAG,IAAIlB,MAAJ,CAAWwB,cAAX,EAA2BF,iBAA3B,CAAZ;AACD;;AAED,aAAO,CAACR,SAAD,EAAYI,SAAZ,CAAP;AACD;;;;;;SAhEkBjB,iB","sourcesContent":["import Square from \"../../Domain/Square/Square\";\nimport Vector2d from \"../../Domain/Vector/Vector2d\";\n\nexport default class PerspectiveSquare {\n  /**\n   * Depth of perspective\n   */\n  public depth: number;\n  /**\n   * Max front square moves away from the vanishPoint.\n   */\n  public maxSquareDisplacement: number;\n\n  private _squareCenter: Vector2d;\n  private _square: Square;\n\n  public constructor(square: Square, depth = 100, maxSquareDisplacement = 60) {\n    this._squareCenter = square.center;\n\n    this._square = square.clone();\n\n    this.depth = depth;\n    this.maxSquareDisplacement = maxSquareDisplacement;\n  }\n\n  public getSquares(vanishPoint: Vector2d): [Square, Square] {\n    // Calculate first square\n    let displacementVector = this._squareCenter.minus(vanishPoint);\n    if (displacementVector.magnitude > this.maxSquareDisplacement) {\n      displacementVector = displacementVector.scaleTo(\n        this.maxSquareDisplacement\n      );\n    }\n\n    const squareOne = new Square(\n      this._square.width,\n      this._square.position.plus(displacementVector)\n    );\n\n    // Calculate second square\n    let squareTwo: Square;\n    if (vanishPoint.minus(squareOne.points.a).magnitude < this.depth) {\n      squareTwo = new Square(0, vanishPoint);\n    } else {\n      // Let's break out some fucking math. Alright.\n\n      // Offset is a vector reprsenting the change in position from squareOne to squareTwo.\n      const offset = vanishPoint.minus(squareOne.position).scaleTo(this.depth);\n\n      // To get squareTwo's position, we add offset to squareOne.\n      const squareTwoPosition = offset.plus(squareOne.position);\n\n      // Then let's calculate the width.  This might not be the most efficient, but\n      // we can use similar triangles and compare the distance from the top left point\n      // of squareA to the vanishing point to the distance between squareTwo's position\n      // and the vanishing point and use that ratio to determine the width given the width of squareOne\n      const vanishPointDistance = squareOne.position.minus(vanishPoint)\n        .magnitude;\n\n      const squareTwoWidth =\n        (squareOne.width * (vanishPointDistance - this.depth)) /\n        vanishPointDistance;\n\n      squareTwo = new Square(squareTwoWidth, squareTwoPosition);\n    }\n\n    return [squareOne, squareTwo];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}