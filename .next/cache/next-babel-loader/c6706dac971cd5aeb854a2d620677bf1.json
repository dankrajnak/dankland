{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport useScrollAmount from \"../../../../Hooks/useScrollAmount\";\nimport Card from \"../Card/Card\";\nimport useFullScreen from \"../../../../Hooks/useFullScreen\";\nimport { mappedStepEaser } from \"../../../../../Services/EaseStep/EaseStep.service\";\nimport EasingFunctions from \"../../../../../Services/Ease/Ease.service\";\nimport Link from \"next/link\";\nimport useSafeWindow from \"../../../../Hooks/useSafeWindow\"; // TODO find a better way to do this.\n// @ts-ignore\n\nconst _ref = {},\n      {\n  width,\n  height\n} = _ref,\n      CardPropsSubset = _objectWithoutProperties(_ref, [\"width\", \"height\"]);\n\nconst CardDeckHolder = styled.div`\n  height: ${props => props.height}px;\n  width: 100%;\n`;\nconst CardHolder = styled.div.attrs(props => ({\n  style: {\n    transform: `translate(${props.dx}px, ${props.dy}px)`,\n    zIndex: 2000 - props.order\n  }\n}))`\n  position: fixed;\n`;\nconst PERIOD = 0.4;\nconst EASING_FUNCTION = EasingFunctions.easeInOutQuart;\n/**\n * Creates a scrollable Card Deck.\n * @param {Props} props\n */\n\nconst CardDeck = props => {\n  const scroll = useScrollAmount(true);\n  const [window] = useSafeWindow();\n  const [windowWidth, windowHeight, flash] = useFullScreen(); // This is the position on the screen the deck sits.  It's a computed value based on the windowWidth.\n\n  const deckPosition = React.useMemo(() => (windowWidth - props.cardsWidth) / 2, [props.cardsWidth, windowWidth]);\n  const scrollDemap = React.useMemo(() => val => deckPosition - windowWidth * val, [deckPosition, windowWidth]);\n  const scrollLength = windowHeight * 5;\n  const cardPositionStart = deckPosition;\n  const cardPositionEnd = -props.cardsWidth; // Memoize stepEaser to only generate range and getPosition when the cards length changes.\n\n  const [getPosition, getEaseStart] = React.useMemo(() => mappedStepEaser(0, scrollLength, cardPositionStart, cardPositionEnd)(props.cards.length - 1, PERIOD, EASING_FUNCTION), [cardPositionEnd, cardPositionStart, props.cards.length, scrollLength]); // Move to the saved scroll position when this component renders\n\n  React.useLayoutEffect(() => {\n    let timeout;\n\n    if (window) {\n      if (props.scrollToCard) {\n        //Ok, this is hacky, but unless we wait a few milliseconds,\n        // the screen doesn't have time to render and we don't scroll anywhere.\n        // As far as I can tell for now, there's no way to listen for when all the cards have been rendered\n        setTimeout(() => {\n          if (props.scrollToCard) {\n            window.scrollTo(0, // Add a little to the index to give make sure the card on top has moved off of the card below\n            // TODO this should take the easing function into account.\n            getEaseStart(props.scrollToCard + 2 / props.cards.length));\n          }\n        }, 15);\n      }\n    }\n\n    return () => {\n      clearTimeout(timeout);\n    };\n  }, [getEaseStart, props.cards.length, props.scrollToCard, window]);\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(CardDeckHolder, {\n    height: scrollLength + windowHeight\n  }, props.cards.map((card, i) => {\n    // Only draw cards when the card above it has moved and it's on screen.\n    const nextCardPosition = i !== props.cards.length - 1 ? getPosition(scroll, i + 1) : cardPositionStart;\n    const currentCardPosition = getPosition(scroll, i);\n    const prevCardPosition = i !== 0 ? getPosition(scroll, i - 1) : cardPositionEnd;\n    const shouldNotDrawCard = currentCardPosition === nextCardPosition && currentCardPosition !== deckPosition || prevCardPosition === cardPositionStart;\n    return __jsx(Link, {\n      href: card.link,\n      key: i\n    }, __jsx(\"div\", {\n      className: \"card-deck-card-link\"\n    }, __jsx(CardHolder, {\n      dx: i === props.cards.length - 1 ? cardPositionStart : currentCardPosition,\n      dy: (windowHeight - props.cardsHeight) / 2,\n      order: i\n    }, !shouldNotDrawCard && __jsx(Card, _extends({}, card, {\n      width: props.cardsWidth,\n      height: props.cardsHeight,\n      shadowAmount: i === props.cards.length - 1 ? 0 : scrollDemap(getPosition(scroll, i))\n    })))));\n  }));\n};\n\nexport default CardDeck;","map":null,"metadata":{},"sourceType":"module"}