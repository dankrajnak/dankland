{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport SpatialHashMap from \"../SpatialHashmap/SpatialHashmap\";\nimport MemoService from \"../Memo/Memo.service\";\nimport Vector2d from \"../../Domain/Vector/Vector2d\";\n\nclass State {\n  // x location\n  // y location\n  // previous x location\n  // previous y location\n  // horizontal velocity\n  // vertical velocity\n  // pressure\n  // pressure near\n  // 'nearness' to neighbour\n  // Three.js mesh for rendering\n  constructor(particleCount) {\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"oldX\", void 0);\n\n    _defineProperty(this, \"oldY\", void 0);\n\n    _defineProperty(this, \"vx\", void 0);\n\n    _defineProperty(this, \"vy\", void 0);\n\n    _defineProperty(this, \"p\", void 0);\n\n    _defineProperty(this, \"pNear\", void 0);\n\n    _defineProperty(this, \"g\", void 0);\n\n    _defineProperty(this, \"mesh\", void 0);\n\n    this.x = new Float32Array(particleCount).fill(250);\n    this.y = new Float32Array(particleCount).fill(250);\n    this.oldX = new Float32Array(particleCount).fill(250);\n    this.oldY = new Float32Array(particleCount).fill(250);\n    this.vx = new Float32Array(particleCount);\n    this.vy = new Float32Array(particleCount);\n    this.p = new Float32Array(particleCount);\n    this.pNear = new Float32Array(particleCount);\n    this.g = new Float32Array(particleCount);\n    this.mesh = [];\n  }\n\n  getPoint(index) {\n    return new Vector2d(this.x[index], this.y[index]);\n  }\n\n  getOldPoint(index) {\n    return new Vector2d(this.oldX[index], this.oldY[index]);\n  }\n\n  setPoint(index, val) {\n    this.x[index] = val.x;\n    this.y[index] = val.y;\n  }\n\n}\n\nconst GRAVITY = new Vector2d(0, 9.8);\nconst INTERACTION_RADIUS = 105;\nconst INTERACTION_RADIUS_SQ = INTERACTION_RADIUS ** 2;\nconst STIFFNESS = 35; // NO idea what these should be.\n\nconst STIFFNESS_NEAR = 100;\nconst REST_DENSITY = 5;\nexport default class FluidService {\n  /**\n   * Contents of hashmap are index of point in state.\n   */\n  constructor(particleCount, width, height, dt = 0.0166) {\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"particleCount\", void 0);\n\n    _defineProperty(this, \"dt\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"radiusSq\", void 0);\n\n    _defineProperty(this, \"hashMap\", void 0);\n\n    _defineProperty(this, \"X_GRID_CELLS\", void 0);\n\n    _defineProperty(this, \"Y_GRID_CELLS\", void 0);\n\n    _defineProperty(this, \"gradient\", MemoService((a, b) => {\n      const lsq = a.squaredDistanceTo(b);\n\n      if (lsq > INTERACTION_RADIUS_SQ) {\n        return 0;\n      }\n\n      const distance = Math.sqrt(lsq);\n      return 1 - distance / INTERACTION_RADIUS;\n    }));\n\n    this.state = new State(particleCount); // Initialize points in state randomlu\n\n    for (let i = 0; i < particleCount; i++) {\n      const pos = width / particleCount / 200 * i;\n      this.state.setPoint(i, new Vector2d(pos, pos));\n    }\n\n    this.particleCount = particleCount;\n    this.dt = dt;\n    this.width = width;\n    this.height = height; // TEMP\n\n    this.radius = this.height / 2;\n    this.radiusSq = this.radius * this.radius;\n    this.hashMap = new SpatialHashMap(this.width, this.height); // Calculate number of grid cells\n\n    this.X_GRID_CELLS = 54;\n    this.Y_GRID_CELLS = 54;\n  }\n  /**\n   * Calculates the next state\n   */\n\n\n  next() {\n    this.passOne();\n    this.passTwo();\n    this.passThree();\n    return this.state;\n  }\n\n  applyGlobalForces(index, dt) {\n    const force = GRAVITY.times(dt);\n    this.state.vx[index] += force.x;\n    this.state.vy[index] += force.y;\n  }\n\n  getXGrid(pos) {\n    return pos / this.width * this.X_GRID_CELLS;\n  }\n\n  getYGrid(pos) {\n    return pos / this.height * this.Y_GRID_CELLS;\n  }\n  /**\n   * Returns a *'gradient'* describing how far away these two points are.\n   * In this context, a gradient is between 0 and 1, with 1 indicating that the\n   * points are very close to eachother, and 0 indicating they are far.\n   *\n   * More concretely, 0 indicates that the points are at least `INTERACTION_RADIUS`\n   * apart.\n   * @param a first point\n   * @param b second point\n   *\n   * @returns gradient for these two points.\n   */\n\n\n  /**\n   * **Not Pure**\n   *\n   * Returns neighbors with a non-zero gradient and stores their\n   * gradients in the global state.\n   * @param i index of the point in state.\n   * @returns array of indexes of all neighbors\n   */\n  getNeighborsWithGradients(i) {\n    const radius = INTERACTION_RADIUS / this.width * this.X_GRID_CELLS;\n    const point = this.state.getPoint(i);\n    const results = this.hashMap.query(this.getXGrid(point.x), this.getYGrid(point.y), radius);\n    const neighbors = [];\n\n    for (let k = 0; k < results.length; k++) {\n      const n = results[k];\n      if (i === n) continue; // Skip itself\n\n      const g = this.gradient(point, this.state.getPoint(n));\n      if (g === 0) continue;\n      this.state.g[n] = g; // Store the gradient\n\n      neighbors.push(n); // Push the neighbor to neighbors\n    }\n\n    return neighbors;\n  }\n  /**\n   * **Not Pure**\n   * Updates global state with pressures for this point.\n   */\n\n\n  updatePressure(index, neighbors) {\n    let density = 0;\n    let nearDensity = 0;\n\n    for (let k = 0; k < neighbors.length; k++) {\n      const g = this.state.g[neighbors[k]]; // Get g for this neighbour\n\n      density += g * g;\n      nearDensity += g * g * g;\n    }\n\n    this.state.p[index] = STIFFNESS * (density - REST_DENSITY);\n    this.state.pNear[index] = STIFFNESS_NEAR * nearDensity;\n  }\n  /**\n   * **Not Pure**\n   * Applies density relaxation algorithm to point.\n   */\n\n\n  relax(index, neighbors, dt) {\n    const pos = this.state.getPoint(index);\n\n    for (let k = 0; k < neighbors.length; k++) {\n      const n = neighbors[k];\n      const g = this.state.g[n];\n      const nPos = this.state.getPoint(n);\n      const magnitude = this.state.p[index] * g + this.state.pNear[index] * g * g;\n      const direction = nPos.minus(pos).approxUnit;\n      const force = direction.times(magnitude);\n      const d = force.times(dt * dt).times(-0.05);\n      this.state.setPoint(index, this.state.getPoint(index).plus(d.times(-0.5)));\n      this.state.setPoint(n, this.state.getPoint(n).plus(d.times(0.5)));\n    }\n  }\n\n  contain(index) {\n    const pos = this.state.getPoint(index);\n\n    if (pos.magnitudeSquared > this.radiusSq) {\n      const unitPos = pos.normalized;\n      const newPos = unitPos.times(this.radius);\n      this.state.setPoint(index, newPos);\n    }\n  }\n\n  calculateVelocity(index, dt) {\n    const pos = this.state.getPoint(index);\n    const old = this.state.getOldPoint(index);\n    const v = pos.minus(old).times(1 / dt);\n    this.state.vx[index] = v.x;\n    this.state.vy[index] = v.y;\n  }\n  /**\n   * Pass One.  Not sure what else to say about this.\n   */\n\n\n  passOne() {\n    for (let i = 0; i < this.particleCount; i++) {\n      const point = this.state.getPoint(i); // Update old state\n\n      this.state.oldX[i] = point.x;\n      this.state.oldY[i] = point.y; // Apply global forces\n\n      this.applyGlobalForces(i, this.dt); // Update positions\n\n      this.state.setPoint(i, this.state.getPoint(i).plus(new Vector2d(this.state.vx[i], this.state.vy[i]).times(this.dt))); // Store points in spatial hashmap\n\n      this.hashMap.add(this.getXGrid(point.x), this.getYGrid(point.y), i);\n    }\n  }\n\n  passTwo() {\n    for (let i = 0; i < this.particleCount; i++) {\n      const neighbours = this.getNeighborsWithGradients(i);\n      this.updatePressure(i, neighbours); // perform double density relaxation\n\n      this.relax(i, neighbours, this.dt);\n    }\n\n    this.hashMap.clear();\n  }\n  /**\n   * Contain particles within a boundary.\n   */\n\n\n  passThree() {\n    for (let i = 0; i < this.particleCount; i++) {\n      // Constrain the particles to a container\n      this.contain(i); // Calculate new velocities\n\n      this.calculateVelocity(i, this.dt); // Update\n      // this.state.mesh[i].position.set(state.x[i], state.y[i], 0);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}