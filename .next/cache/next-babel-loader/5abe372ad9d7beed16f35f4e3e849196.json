{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from \"react\";\nimport TypeWriterService from \"../../../Services/TypeWriter/TypeWriter.service\";\n/**\n * A representation of a delayed state of the typed text.\n */\n\nexport const DEFAULT_TYPE_CONFIG = {\n  typeDelay: {\n    base: 100,\n    variance: 50\n  },\n  mistakeRealizeDelay: {\n    base: 250,\n    variance: 50\n  },\n  mistakeProbability: 0.02\n};\n/**\n * Type the provided text according to the type config.\n */\n\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case \"TYPE_TEXT\":\n      let textToType = \"\";\n\n      if (state.sequence.length) {\n        // Get the value of the text once the sequence is completed.\n        // We should add the text provided to this text.\n        textToType = state.sequence[state.sequence.length - 1].text;\n      }\n\n      const typeSequence = []; // In the special case in which we're just typing an empty string, add a DelayNode\n      // to call the listener if there is one.\n\n      if (action.payload.text === \"\" && action.payload.listener) {\n        return _objectSpread({}, state, {\n          sequence: state.sequence.concat([{\n            text: textToType,\n            delay: 0,\n            listener: action.payload.listener\n          }])\n        });\n      } // Function for generating a the delay of typing a character.\n\n\n      const getTypeDelay = () => Math.max(0, action.payload.typeConfig.typeDelay.base + Math.random() * action.payload.typeConfig.typeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance); // Function for generating the delay of realizing a mistake.\n\n\n      const getMistakeDelay = () => Math.max(0, action.payload.typeConfig.mistakeRealizeDelay.base + Math.random() * action.payload.typeConfig.mistakeRealizeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance); // For each character...\n\n\n      action.payload.text.split(\"\").forEach((char, i) => {\n        // Possibly make a mistake\n        if (Math.random() <= action.payload.typeConfig.mistakeProbability) {\n          //Type mistake character\n          typeSequence.push({\n            text: textToType + TypeWriterService.getMistakeCharacter(char),\n            delay: getTypeDelay()\n          }); // Then erase it.\n\n          typeSequence.push({\n            text: textToType,\n            delay: getMistakeDelay()\n          });\n        } // The next text should include the next character\n\n\n        textToType += char; // If this is the last node to add, add the listener to the node.\n\n        if (i === action.payload.text.length - 1 && action.payload.listener) {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay(),\n            listener: action.payload.listener\n          });\n        } else {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay()\n          });\n        }\n      });\n      return _objectSpread({}, state, {\n        sequence: state.sequence.concat(typeSequence)\n      });\n\n    case \"DELETE_ALL\":\n      //Don't do anything if the current value is empty\n      if (!state.currentValue.length) {\n        return state;\n      } //Immediately delete all characters.\n\n\n      const newSequence = state.currentValue.split(\"\").slice(0, state.currentValue.length - 1) // I.E. \"123\" -> [\"12\", \"1\", \"\"]\n      .reduce((sum, char) => [sum[0] + char].concat(sum), [\"\"]) // Deletes take 10 miliseconds (this value is not configurable yet.)\n      .map(text => ({\n        text,\n        delay: 10\n      }));\n      return _objectSpread({}, state, {\n        sequence: newSequence\n      });\n\n    case \"WAIT_FOR_NEXT_NODE\":\n      return _objectSpread({}, state, {\n        isWaiting: true\n      });\n\n    case \"TYPE_NODE\":\n      return {\n        currentValue: state.sequence[0].text,\n        sequence: state.sequence.slice(1),\n        isWaiting: false\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Types some characters.  It's pretty sick.\n *\n * @param initialText - the value of text will start with this value\n * @returns [currentValueOfText, setText, isIdle]\n */\nconst useTypeWriter = (initialText = \"\") => {\n  const [state, dispatch] = React.useReducer(reducer, {\n    currentValue: initialText,\n    sequence: [],\n    isWaiting: false\n  });\n  const nextNodeTimeout = React.useRef(null);\n  React.useEffect(() => {\n    if (state.isWaiting || !state.sequence.length) {\n      return;\n    }\n\n    const nextNode = state.sequence[0];\n    dispatch({\n      type: \"WAIT_FOR_NEXT_NODE\",\n      payload: null\n    });\n    nextNodeTimeout.current = setTimeout(() => {\n      dispatch({\n        type: \"TYPE_NODE\",\n        payload: null\n      });\n\n      if (nextNode.listener) {\n        nextNode.listener();\n      }\n    }, nextNode.delay);\n  }, [state]);\n  React.useEffect(() => () => {\n    nextNodeTimeout.current !== null && clearTimeout(nextNodeTimeout.current);\n  }, []);\n  /**\n   * Use ref so this function can be used in effects and won't cause\n   * the effect to rerun after state changes.\n   */\n\n  const typeNextText = React.useRef((nextText, config) => {\n    dispatch({\n      type: \"DELETE_ALL\",\n      payload: null\n    });\n\n    const typeTextPayload = _objectSpread({}, config, {\n      //If a config.typeConfig is provided set it to the type config, otherwise use the default\n      typeConfig: config && config.typeConfig || DEFAULT_TYPE_CONFIG,\n      text: nextText\n    });\n\n    dispatch({\n      type: \"TYPE_TEXT\",\n      payload: typeTextPayload\n    });\n  });\n  return [state.currentValue, typeNextText.current, state.sequence.length === 0];\n};\n\nexport default useTypeWriter;","map":null,"metadata":{},"sourceType":"module"}