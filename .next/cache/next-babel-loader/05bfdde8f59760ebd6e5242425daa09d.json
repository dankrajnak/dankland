{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime-corejs2/helpers/esm/taggedTemplateLiteral\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n  position: fixed;\\n  top: 8%;\\n  left: 8%;\\n  width: 100%;\\n  a {\\n    text-decoration: none;\\n    color: #222;\\n    &:hover {\\n      border-bottom: solid 1px #222;\\n    }\\n  }\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  position: fixed;\\n  bottom: 20px;\\n  width: 100%;\\n  text-align: center;\\n  font-size: small;\\n  color: #aaa;\\n  z-index: 5000;\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport Link from \"next/link\";\nimport useFullScreen from \"../../../Hooks/useFullScreen\";\nimport useScrollAmount from \"../../../Hooks/useScrollAmount\";\nimport CardDeck from \"./CardDeck/CardDeck\";\nvar ScrollMessage = styled.div.attrs(function (props) {\n  return {\n    style: {\n      opacity: props.opacity\n    }\n  };\n})(_templateObject());\nvar AboutContainer = styled.div(_templateObject2());\n/**\n * Pages are represented as cards on a deck. As the user scrolls the cards roll off the deck\n * offscreen.  Known to be a little buggy on iphones.\n */\n\nvar CardMenu = function CardMenu(_ref) {\n  var routeProps = _ref.routeProps,\n      cards = _ref.cards;\n\n  var _useFullScreen = useFullScreen(),\n      _useFullScreen2 = _slicedToArray(_useFullScreen, 3),\n      width = _useFullScreen2[0],\n      height = _useFullScreen2[1],\n      flash = _useFullScreen2[2];\n\n  var cardWidth = React.useMemo(function () {\n    return Math.min(500, width * 0.9);\n  }, [width]);\n  var cardHeight = React.useMemo(function () {\n    return Math.min(500, height * 0.7);\n  }, [height]);\n  var cardsWithDimensions = React.useMemo(function () {\n    return cards.map(function (card) {\n      return _objectSpread({}, card, {\n        background: __jsx(card.background, {\n          width: cardWidth,\n          height: cardHeight\n        })\n      });\n    });\n  }, [cardHeight, cardWidth, cards]);\n  var scrollToCard = React.useMemo(function () {\n    if (routeProps.location && routeProps.location.state && routeProps.location.state.prevPath) {\n      var prevLocation = routeProps.location.state.prevPath;\n      var index = cards.findIndex(function (card) {\n        return card.link === prevLocation;\n      });\n      return index === -1 ? null : index;\n    }\n\n    return null;\n  }, [cards, routeProps.location]);\n  var scroll = useScrollAmount();\n\n  if (flash) {\n    return flash;\n  }\n\n  return __jsx(React.Fragment, null, __jsx(AboutContainer, null, __jsx(Link, {\n    href: \"/about\"\n  }, \"About\")), __jsx(CardDeck, {\n    cards: cardsWithDimensions,\n    width: width,\n    cardsWidth: cardWidth,\n    cardsHeight: cardHeight,\n    scrollToCard: scrollToCard\n  }), __jsx(ScrollMessage, {\n    opacity: (1 - scroll / height) * 2 || 0\n  }, \"Scroll Up\"));\n};\n\nexport default CardMenu;","map":null,"metadata":{},"sourceType":"module"}