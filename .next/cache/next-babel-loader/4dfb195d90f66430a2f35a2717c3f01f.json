{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\n\n/**\n * *Bad name, I know.*  This method makes it possible\n * to 'join' together the easing of various things.  It was\n * initially designed to help ease cards off of a card deck.\n *\n * For example, let's say you have three cards sitting on the deck.\n * You want to ease the first, then the second, and finally the third\n * off of the deck.  The second should move some time after the first,\n * the third after the second.  Let's say that you want to have a function\n * to which you provide one number indicating the progress through the animation\n * and an index indicating a card and you want to get the position of that card.\n *\n * This function does that, but everything is normalized.  Provide a the number\n * of things you'd like to ease, a period (if 0 then all items will move at the same\n * time, 1, all items will move directly after the previous has finished, etc.), and\n * an easing function.  This function will return a range and the function mentioned\n * above which takes in a progress number (between 0 and 1) and an index.   The range is helpful to selectively\n * make animations slower which have a larger period or more elements.\n *\n * @param {number} numThings - number of things to ease\n * @param {number} period - if 0 things will move together, if 1 will move right after eachother, .5 will move halfway, etc.\n * @param {function} easeFunction - function which takes in a number between 0 and 1\n *  and outputs another number between 0 and 1.\n * @returns {[number, function, function]} the range, a function which inputs a progress number\n * and an index and outputs the value of the thing with that index for that progress number, and a\n * function which takes an index and returns the place in the range that index starts to be eased.\n */\nvar stepEaser = function stepEaser(numStages) {\n  var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var easeFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (x) {\n    return x;\n  };\n  // Figure out when the last stage will go and add one to it.\n  var length = (numStages - 1) * period + 1;\n\n  var getValue = function getValue(progress, index) {\n    var val = progress * length - index * period;\n\n    if (val < 0) {\n      return 0;\n    }\n\n    if (val > 1) {\n      return 1;\n    }\n\n    return easeFunction(val);\n  };\n\n  var getEaseStart = function getEaseStart(index) {\n    return index * period / length;\n  };\n\n  return [getValue, getEaseStart];\n};\n\nexport var mappedStepEaser = function mappedStepEaser(inputFrom, inputTo, outputFrom, outputTo) {\n  return function (numStages) {\n    var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var easeFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (x) {\n      return x;\n    };\n\n    var inputMap = function inputMap(val) {\n      return (val - inputFrom) / (inputTo - inputFrom);\n    };\n\n    var outputMap = function outputMap(val) {\n      return val * (outputTo - outputFrom) + outputFrom;\n    };\n\n    var inputMapInverse = function inputMapInverse(val) {\n      return val * (inputTo - inputFrom) + inputFrom;\n    };\n\n    var _stepEaser = stepEaser(numStages, period, easeFunction),\n        _stepEaser2 = _slicedToArray(_stepEaser, 2),\n        getValue = _stepEaser2[0],\n        getPosition = _stepEaser2[1];\n\n    return [function (progress, index) {\n      return outputMap(getValue(inputMap(progress), index));\n    }, function (index) {\n      return inputMapInverse(getPosition(index));\n    }];\n  };\n};\nexport default stepEaser;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/EaseStep/EaseStep.service.ts"],"names":["stepEaser","numStages","period","easeFunction","x","length","getValue","progress","index","val","getEaseStart","mappedStepEaser","inputFrom","inputTo","outputFrom","outputTo","inputMap","outputMap","inputMapInverse","getPosition"],"mappings":";;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,IAAMA,SAAwB,GAAG,SAA3BA,SAA2B,CAC/BC,SAD+B,EAI5B;AAAA,MAFHC,MAEG,uEAFM,CAEN;AAAA,MADHC,YACG,uEADY,UAAAC,CAAC;AAAA,WAAIA,CAAJ;AAAA,GACb;AACH;AACA,MAAMC,MAAM,GAAG,CAACJ,SAAS,GAAG,CAAb,IAAkBC,MAAlB,GAA2B,CAA1C;;AACA,MAAMI,QAAQ,GAAG,SAAXA,QAAW,CAACC,QAAD,EAAmBC,KAAnB,EAAqC;AACpD,QAAMC,GAAG,GAAGF,QAAQ,GAAGF,MAAX,GAAoBG,KAAK,GAAGN,MAAxC;;AACA,QAAIO,GAAG,GAAG,CAAV,EAAa;AACX,aAAO,CAAP;AACD;;AACD,QAAIA,GAAG,GAAG,CAAV,EAAa;AACX,aAAO,CAAP;AACD;;AACD,WAAON,YAAY,CAACM,GAAD,CAAnB;AACD,GATD;;AAUA,MAAMC,YAAY,GAAG,SAAfA,YAAe,CAACF,KAAD;AAAA,WAAoBA,KAAK,GAAGN,MAAT,GAAmBG,MAAtC;AAAA,GAArB;;AACA,SAAO,CAACC,QAAD,EAAWI,YAAX,CAAP;AACD,CAnBD;;AAqBA,OAAO,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAC7BC,SAD6B,EAE7BC,OAF6B,EAG7BC,UAH6B,EAI7BC,QAJ6B;AAAA,SAKX,UAClBd,SADkB,EAIf;AAAA,QAFHC,MAEG,uEAFM,CAEN;AAAA,QADHC,YACG,uEADY,UAACC,CAAD;AAAA,aAAeA,CAAf;AAAA,KACZ;;AACH,QAAMY,QAAQ,GAAG,SAAXA,QAAW,CAACP,GAAD;AAAA,aAAiB,CAACA,GAAG,GAAGG,SAAP,KAAqBC,OAAO,GAAGD,SAA/B,CAAjB;AAAA,KAAjB;;AAEA,QAAMK,SAAS,GAAG,SAAZA,SAAY,CAACR,GAAD;AAAA,aAAiBA,GAAG,IAAIM,QAAQ,GAAGD,UAAf,CAAH,GAAgCA,UAAjD;AAAA,KAAlB;;AAEA,QAAMI,eAAe,GAAG,SAAlBA,eAAkB,CAACT,GAAD;AAAA,aACtBA,GAAG,IAAII,OAAO,GAAGD,SAAd,CAAH,GAA8BA,SADR;AAAA,KAAxB;;AALG,qBAQ6BZ,SAAS,CAACC,SAAD,EAAYC,MAAZ,EAAoBC,YAApB,CARtC;AAAA;AAAA,QAQIG,QARJ;AAAA,QAQca,WARd;;AAUH,WAAO,CACL,UAACZ,QAAD,EAAmBC,KAAnB;AAAA,aACES,SAAS,CAACX,QAAQ,CAACU,QAAQ,CAACT,QAAD,CAAT,EAAqBC,KAArB,CAAT,CADX;AAAA,KADK,EAGL,UAACA,KAAD;AAAA,aAAmBU,eAAe,CAACC,WAAW,CAACX,KAAD,CAAZ,CAAlC;AAAA,KAHK,CAAP;AAKD,GAxB8B;AAAA,CAAxB;AA0BP,eAAeR,SAAf","sourcesContent":["type StepEaserType = (\n  numStages: number,\n  period?: number,\n  easeFunction?: (x0: number) => number\n) => [(progress: number, index: number) => number, (index: number) => number];\n/**\n * *Bad name, I know.*  This method makes it possible\n * to 'join' together the easing of various things.  It was\n * initially designed to help ease cards off of a card deck.\n *\n * For example, let's say you have three cards sitting on the deck.\n * You want to ease the first, then the second, and finally the third\n * off of the deck.  The second should move some time after the first,\n * the third after the second.  Let's say that you want to have a function\n * to which you provide one number indicating the progress through the animation\n * and an index indicating a card and you want to get the position of that card.\n *\n * This function does that, but everything is normalized.  Provide a the number\n * of things you'd like to ease, a period (if 0 then all items will move at the same\n * time, 1, all items will move directly after the previous has finished, etc.), and\n * an easing function.  This function will return a range and the function mentioned\n * above which takes in a progress number (between 0 and 1) and an index.   The range is helpful to selectively\n * make animations slower which have a larger period or more elements.\n *\n * @param {number} numThings - number of things to ease\n * @param {number} period - if 0 things will move together, if 1 will move right after eachother, .5 will move halfway, etc.\n * @param {function} easeFunction - function which takes in a number between 0 and 1\n *  and outputs another number between 0 and 1.\n * @returns {[number, function, function]} the range, a function which inputs a progress number\n * and an index and outputs the value of the thing with that index for that progress number, and a\n * function which takes an index and returns the place in the range that index starts to be eased.\n */\nconst stepEaser: StepEaserType = (\n  numStages,\n  period = 1,\n  easeFunction = x => x\n) => {\n  // Figure out when the last stage will go and add one to it.\n  const length = (numStages - 1) * period + 1;\n  const getValue = (progress: number, index: number) => {\n    const val = progress * length - index * period;\n    if (val < 0) {\n      return 0;\n    }\n    if (val > 1) {\n      return 1;\n    }\n    return easeFunction(val);\n  };\n  const getEaseStart = (index: number) => (index * period) / length;\n  return [getValue, getEaseStart];\n};\n\nexport const mappedStepEaser = (\n  inputFrom: number,\n  inputTo: number,\n  outputFrom: number,\n  outputTo: number\n): StepEaserType => (\n  numStages: number,\n  period = 1,\n  easeFunction = (x: number) => x\n) => {\n  const inputMap = (val: number) => (val - inputFrom) / (inputTo - inputFrom);\n\n  const outputMap = (val: number) => val * (outputTo - outputFrom) + outputFrom;\n\n  const inputMapInverse = (val: number) =>\n    val * (inputTo - inputFrom) + inputFrom;\n\n  const [getValue, getPosition] = stepEaser(numStages, period, easeFunction);\n\n  return [\n    (progress: number, index: number) =>\n      outputMap(getValue(inputMap(progress), index)),\n    (index: number) => inputMapInverse(getPosition(index)),\n  ];\n};\n\nexport default stepEaser;\n"]},"metadata":{},"sourceType":"module"}