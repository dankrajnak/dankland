{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Square from \"../../Domain/Square/Square\";\nexport default class PerspectiveSquare {\n  /**\n   * Depth of perspective\n   */\n\n  /**\n   * Max front square moves away from the vanishPoint.\n   */\n  constructor(square, depth = 100, maxSquareDisplacement = 60) {\n    _defineProperty(this, \"depth\", void 0);\n\n    _defineProperty(this, \"maxSquareDisplacement\", void 0);\n\n    _defineProperty(this, \"_squareCenter\", void 0);\n\n    _defineProperty(this, \"_square\", void 0);\n\n    this._squareCenter = square.center;\n    this._square = square.clone();\n    this.depth = depth;\n    this.maxSquareDisplacement = maxSquareDisplacement;\n  }\n\n  getSquares(vanishPoint) {\n    // Calculate first square\n    let displacementVector = this._squareCenter.minus(vanishPoint);\n\n    if (displacementVector.magnitude > this.maxSquareDisplacement) {\n      displacementVector = displacementVector.scaleTo(this.maxSquareDisplacement);\n    }\n\n    const squareOne = new Square(this._square.width, this._square.position.plus(displacementVector)); // Calculate second square\n\n    let squareTwo;\n\n    if (vanishPoint.minus(squareOne.points.a).magnitude < this.depth) {\n      squareTwo = new Square(0, vanishPoint);\n    } else {\n      // Let's break out some fucking math. Alright.\n      // Offset is a vector reprsenting the change in position from squareOne to squareTwo.\n      const offset = vanishPoint.minus(squareOne.position).scaleTo(this.depth); // To get squareTwo's position, we add offset to squareOne.\n\n      const squareTwoPosition = offset.plus(squareOne.position); // Then let's calculate the width.  This might not be the most efficient, but\n      // we can use similar triangles and compare the distance from the top left point\n      // of squareA to the vanishing point to the distance between squareTwo's position\n      // and the vanishing point and use that ratio to determine the width given the width of squareOne\n\n      const vanishPointDistance = squareOne.position.minus(vanishPoint).magnitude;\n      const squareTwoWidth = squareOne.width * (vanishPointDistance - this.depth) / vanishPointDistance;\n      squareTwo = new Square(squareTwoWidth, squareTwoPosition);\n    }\n\n    return [squareOne, squareTwo];\n  }\n\n}","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/Services/PerspectiveSquare/PerspectiveSquare.service.ts"],"names":["Square","PerspectiveSquare","constructor","square","depth","maxSquareDisplacement","_squareCenter","center","_square","clone","getSquares","vanishPoint","displacementVector","minus","magnitude","scaleTo","squareOne","width","position","plus","squareTwo","points","a","offset","squareTwoPosition","vanishPointDistance","squareTwoWidth"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,4BAAnB;AAGA,eAAe,MAAMC,iBAAN,CAAwB;AACrC;;;;AAIA;;;AAQOC,EAAAA,WAAP,CAAmBC,MAAnB,EAAmCC,KAAK,GAAG,GAA3C,EAAgDC,qBAAqB,GAAG,EAAxE,EAA4E;AAAA;;AAAA;;AAAA;;AAAA;;AAC1E,SAAKC,aAAL,GAAqBH,MAAM,CAACI,MAA5B;AAEA,SAAKC,OAAL,GAAeL,MAAM,CAACM,KAAP,EAAf;AAEA,SAAKL,KAAL,GAAaA,KAAb;AACA,SAAKC,qBAAL,GAA6BA,qBAA7B;AACD;;AAEMK,EAAAA,UAAP,CAAkBC,WAAlB,EAA2D;AACzD;AACA,QAAIC,kBAAkB,GAAG,KAAKN,aAAL,CAAmBO,KAAnB,CAAyBF,WAAzB,CAAzB;;AACA,QAAIC,kBAAkB,CAACE,SAAnB,GAA+B,KAAKT,qBAAxC,EAA+D;AAC7DO,MAAAA,kBAAkB,GAAGA,kBAAkB,CAACG,OAAnB,CACnB,KAAKV,qBADc,CAArB;AAGD;;AAED,UAAMW,SAAS,GAAG,IAAIhB,MAAJ,CAChB,KAAKQ,OAAL,CAAaS,KADG,EAEhB,KAAKT,OAAL,CAAaU,QAAb,CAAsBC,IAAtB,CAA2BP,kBAA3B,CAFgB,CAAlB,CATyD,CAczD;;AACA,QAAIQ,SAAJ;;AACA,QAAIT,WAAW,CAACE,KAAZ,CAAkBG,SAAS,CAACK,MAAV,CAAiBC,CAAnC,EAAsCR,SAAtC,GAAkD,KAAKV,KAA3D,EAAkE;AAChEgB,MAAAA,SAAS,GAAG,IAAIpB,MAAJ,CAAW,CAAX,EAAcW,WAAd,CAAZ;AACD,KAFD,MAEO;AACL;AAEA;AACA,YAAMY,MAAM,GAAGZ,WAAW,CAACE,KAAZ,CAAkBG,SAAS,CAACE,QAA5B,EAAsCH,OAAtC,CAA8C,KAAKX,KAAnD,CAAf,CAJK,CAML;;AACA,YAAMoB,iBAAiB,GAAGD,MAAM,CAACJ,IAAP,CAAYH,SAAS,CAACE,QAAtB,CAA1B,CAPK,CASL;AACA;AACA;AACA;;AACA,YAAMO,mBAAmB,GAAGT,SAAS,CAACE,QAAV,CAAmBL,KAAnB,CAAyBF,WAAzB,EACzBG,SADH;AAGA,YAAMY,cAAc,GACjBV,SAAS,CAACC,KAAV,IAAmBQ,mBAAmB,GAAG,KAAKrB,KAA9C,CAAD,GACAqB,mBAFF;AAIAL,MAAAA,SAAS,GAAG,IAAIpB,MAAJ,CAAW0B,cAAX,EAA2BF,iBAA3B,CAAZ;AACD;;AAED,WAAO,CAACR,SAAD,EAAYI,SAAZ,CAAP;AACD;;AAhEoC","sourcesContent":["import Square from \"../../Domain/Square/Square\";\nimport Vector2d from \"../../Domain/Vector/Vector2d\";\n\nexport default class PerspectiveSquare {\n  /**\n   * Depth of perspective\n   */\n  public depth: number;\n  /**\n   * Max front square moves away from the vanishPoint.\n   */\n  public maxSquareDisplacement: number;\n\n  private _squareCenter: Vector2d;\n  private _square: Square;\n\n  public constructor(square: Square, depth = 100, maxSquareDisplacement = 60) {\n    this._squareCenter = square.center;\n\n    this._square = square.clone();\n\n    this.depth = depth;\n    this.maxSquareDisplacement = maxSquareDisplacement;\n  }\n\n  public getSquares(vanishPoint: Vector2d): [Square, Square] {\n    // Calculate first square\n    let displacementVector = this._squareCenter.minus(vanishPoint);\n    if (displacementVector.magnitude > this.maxSquareDisplacement) {\n      displacementVector = displacementVector.scaleTo(\n        this.maxSquareDisplacement\n      );\n    }\n\n    const squareOne = new Square(\n      this._square.width,\n      this._square.position.plus(displacementVector)\n    );\n\n    // Calculate second square\n    let squareTwo: Square;\n    if (vanishPoint.minus(squareOne.points.a).magnitude < this.depth) {\n      squareTwo = new Square(0, vanishPoint);\n    } else {\n      // Let's break out some fucking math. Alright.\n\n      // Offset is a vector reprsenting the change in position from squareOne to squareTwo.\n      const offset = vanishPoint.minus(squareOne.position).scaleTo(this.depth);\n\n      // To get squareTwo's position, we add offset to squareOne.\n      const squareTwoPosition = offset.plus(squareOne.position);\n\n      // Then let's calculate the width.  This might not be the most efficient, but\n      // we can use similar triangles and compare the distance from the top left point\n      // of squareA to the vanishing point to the distance between squareTwo's position\n      // and the vanishing point and use that ratio to determine the width given the width of squareOne\n      const vanishPointDistance = squareOne.position.minus(vanishPoint)\n        .magnitude;\n\n      const squareTwoWidth =\n        (squareOne.width * (vanishPointDistance - this.depth)) /\n        vanishPointDistance;\n\n      squareTwo = new Square(squareTwoWidth, squareTwoPosition);\n    }\n\n    return [squareOne, squareTwo];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}