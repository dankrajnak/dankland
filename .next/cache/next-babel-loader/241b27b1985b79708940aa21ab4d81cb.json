{"ast":null,"code":"import * as THREE from \"three\";\nlet renderer;\nlet canvas;\nlet eventListener; //eslint-disable-line\n\nlet animationFrame;\n\nfunction render(pointLights, scene, camera) {\n  let time = performance.now() * 0.001;\n  pointLights.forEach(light => {\n    light.position.x = Math.sin(time * 0.6) * 9;\n    light.position.y = Math.sin(time * 0.7) * 9 + 8;\n    light.position.z = light.position.z * 1.002 - 0.01;\n    light.rotation.x = time;\n    light.rotation.z = time;\n    time += 100;\n  });\n\n  if (pointLights[0] && pointLights[0].position.z < -1000) {\n    //@ts-ignore\n    scene.remove(pointLights.shift());\n  }\n\n  renderer.render(scene, camera);\n}\n\nconst generateTexture = () => {\n  let c = document.createElement(\"canvas\");\n  c.width = 2;\n  c.height = 2;\n  var context = c.getContext(\"2d\");\n\n  if (context) {\n    context.fillStyle = \"white\";\n    context.fillRect(0, 1, 2, 1);\n  }\n\n  return c;\n};\n\nfunction animate(pointLights, scene, camera) {\n  animationFrame = requestAnimationFrame(() => animate(pointLights, scene, camera));\n  render(pointLights, scene, camera);\n}\n/**\n * Creates a Light sphere with the given color\n * @param {number} color - hex value of the light color\n */\n\n\nconst createLight = color => {\n  const intensity = 1.5; // Set up point light\n\n  const pointLight = new THREE.PointLight(color, intensity, 20);\n  pointLight.castShadow = true;\n  pointLight.shadow.camera.near = 1;\n  pointLight.shadow.camera.far = 60;\n  pointLight.shadow.bias = -0.005; // reduces self-shadowing on double-sided objects\n  //Create sphere to represent the pointlight\n\n  const lightSphereGeometry = new THREE.SphereBufferGeometry(0.3, 12, 6);\n  const lightSpherematerial = new THREE.MeshBasicMaterial({\n    color: color\n  });\n  lightSpherematerial.color.multiplyScalar(intensity);\n  const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSpherematerial);\n  pointLight.add(lightSphere); //Create sphere wrapper for pointlight\n\n  const texture = new THREE.CanvasTexture(generateTexture());\n  texture.magFilter = THREE.NearestFilter;\n  texture.wrapT = THREE.RepeatWrapping;\n  texture.wrapS = THREE.RepeatWrapping;\n  texture.repeat.set(0.5, 3.5);\n  const wrapperGeometry = new THREE.SphereBufferGeometry(2, 32, 8);\n  const wrapperMaterial = new THREE.MeshPhongMaterial({\n    side: THREE.DoubleSide,\n    alphaMap: texture,\n    alphaTest: 0.5\n  });\n  const sphere = new THREE.Mesh(wrapperGeometry, wrapperMaterial);\n  sphere.castShadow = true;\n  sphere.receiveShadow = true;\n  pointLight.add(sphere); // custom distance material\n\n  var distanceMaterial = new THREE.MeshDistanceMaterial({\n    // @ts-ignore\n    alphaMap: wrapperMaterial.alphaMap,\n    alphaTest: wrapperMaterial.alphaTest\n  }); // @ts-ignore\n\n  sphere.customDistanceMaterial = distanceMaterial;\n  return pointLight;\n};\n\nexport function start(container) {\n  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000);\n  camera.position.set(0, 10, 40);\n  const scene = new THREE.Scene();\n  scene.add(new THREE.AmbientLight(0x111122));\n  const pointLights = [];\n  [0xee6666, 0x333388].forEach(color => {\n    const newLight = createLight(color);\n    pointLights.push(newLight);\n    scene.add(newLight);\n  });\n  var geometry = new THREE.BoxBufferGeometry(30, 30, 1000);\n  var material = new THREE.MeshPhongMaterial({\n    color: 0xa0adaf,\n    shininess: 10,\n    specular: 0x111111,\n    side: THREE.BackSide\n  });\n  var mesh = new THREE.Mesh(geometry, material);\n  mesh.position.y = 10;\n  mesh.receiveShadow = true;\n  scene.add(mesh);\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(container.clientWidth, container.clientHeight);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.BasicShadowMap;\n  canvas = container.appendChild(renderer.domElement);\n  eventListener = window.addEventListener(\"click\", () => {\n    const newLight = createLight([0xee6666, 0x333388][Math.floor(Math.random() * 2)]);\n    pointLights.push(newLight);\n    scene.add(newLight);\n  });\n  window.addEventListener(\"mousemove\", event => {\n    camera.position.x = (1 - event.clientX / window.innerWidth) * 20 - 10;\n    camera.position.y = event.clientY / window.innerHeight * 20;\n    camera.lookAt(0, 10, -30);\n  });\n  animate(pointLights, scene, camera);\n}\nexport function stop() {\n  cancelAnimationFrame(animationFrame);\n  canvas.remove();\n  window.removeEventListener(\"click\", eventListener);\n}","map":null,"metadata":{},"sourceType":"module"}