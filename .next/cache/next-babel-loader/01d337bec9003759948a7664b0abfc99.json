{"ast":null,"code":"import * as React from \"react\";\nimport { SpringSystem } from \"rebound\";\nimport throttle from \"../../Services/Throttle/Throttle.service\";\nimport Vector2d from \"../../Domain/Vector/Vector2d\";\n\nconst getCoordinatesFromMouseEvent = event => {\n  const bounds = event.currentTarget.getBoundingClientRect();\n  return new Vector2d(event.clientX - bounds.left, event.clientY - bounds.top);\n};\n\nconst randomPosition = (maxX, maxY) => new Vector2d(Math.random() * maxX, Math.random() * maxY);\n\nconst positionThreshold = 20;\n\nconst getNextPosition = (currentPosition, width, height) => {\n  let newPosition = randomPosition(width, height);\n\n  while (newPosition.minus(currentPosition).magnitude < positionThreshold) {\n    newPosition = randomPosition(width, height);\n  }\n\n  return newPosition;\n};\n\nconst useClickHoverWander = (width, height, initialFocusPoint = new Vector2d(0, 0)) => {\n  const xSpring = React.useRef(null);\n  const ySpring = React.useRef(null);\n  const [focusPoint, setFocusPoint] = React.useState(initialFocusPoint);\n  React.useEffect(() => {\n    const springSystem = new SpringSystem();\n    const springTension = 2;\n    const springFriction = 5;\n    xSpring.current = springSystem.createSpring(springTension, springFriction);\n    ySpring.current = springSystem.createSpring(springTension, springFriction);\n\n    const goToNextPosition = () => {\n      if (!xSpring.current || !ySpring.current) {\n        return;\n      }\n\n      const newPosition = getNextPosition(new Vector2d(xSpring.current.getCurrentValue(), ySpring.current.getCurrentValue()), width, height); // Not sure exactly why, but there's a bug if we set the endValue right away\n      // Somtimes the spring just doesn't move.\n\n      setTimeout(() => {\n        if (xSpring.current && ySpring.current) {\n          xSpring.current.setEndValue(newPosition.x);\n          ySpring.current.setEndValue(newPosition.y);\n        }\n      }, 0);\n    };\n\n    xSpring.current.addListener({\n      onSpringUpdate: spring => {\n        if (!ySpring.current) {\n          return;\n        }\n\n        setFocusPoint(new Vector2d(spring.getCurrentValue(), ySpring.current.getCurrentValue()));\n      },\n      onSpringAtRest: () => {\n        if (ySpring.current && ySpring.current.isAtRest()) {\n          goToNextPosition();\n        }\n      }\n    });\n    ySpring.current.addListener({\n      onSpringUpdate: spring => {\n        if (!xSpring.current) {\n          return;\n        }\n\n        if (xSpring.current.isAtRest()) {\n          setFocusPoint(new Vector2d(xSpring.current.getCurrentValue(), spring.getCurrentValue()));\n        }\n      },\n      onSpringAtRest: () => {\n        if (xSpring.current && xSpring.current.isAtRest()) {\n          goToNextPosition();\n        }\n      }\n    });\n    xSpring.current.setEndValue(Math.random() * width);\n    ySpring.current.setEndValue(Math.random() * height);\n    return () => {\n      xSpring.current && xSpring.current.destroy();\n      ySpring.current && ySpring.current.destroy();\n    };\n  }, [height, width]);\n  const onMouseMove = React.useMemo(() => throttle(event => {\n    const position = getCoordinatesFromMouseEvent(event);\n    xSpring.current && xSpring.current.setEndValue(position.x);\n    ySpring.current && ySpring.current.setEndValue(position.y);\n  }, 100), []);\n  const onClick = React.useMemo(() => event => {\n    const position = getCoordinatesFromMouseEvent(event);\n    xSpring.current && xSpring.current.setEndValue(position.x);\n    ySpring.current && ySpring.current.setEndValue(position.y);\n  }, []);\n  return [focusPoint, {\n    onClick,\n    onMouseMove\n  }];\n};\n\nexport default useClickHoverWander;","map":null,"metadata":{},"sourceType":"module"}