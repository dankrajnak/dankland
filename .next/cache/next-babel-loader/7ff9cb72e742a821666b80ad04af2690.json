{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport SpatialHashMap from \"../SpatialHashmap/SpatialHashmap\";\nimport MemoService from \"../Memo/Memo.service\";\nimport Vector2d from \"../../Domain/Vector/Vector2d\";\n\nvar State =\n/*#__PURE__*/\nfunction () {\n  // x location\n  // y location\n  // previous x location\n  // previous y location\n  // horizontal velocity\n  // vertical velocity\n  // pressure\n  // pressure near\n  // 'nearness' to neighbour\n  // Three.js mesh for rendering\n  function State(particleCount) {\n    _classCallCheck(this, State);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"oldX\", void 0);\n\n    _defineProperty(this, \"oldY\", void 0);\n\n    _defineProperty(this, \"vx\", void 0);\n\n    _defineProperty(this, \"vy\", void 0);\n\n    _defineProperty(this, \"p\", void 0);\n\n    _defineProperty(this, \"pNear\", void 0);\n\n    _defineProperty(this, \"g\", void 0);\n\n    _defineProperty(this, \"mesh\", void 0);\n\n    this.x = new Float32Array(particleCount).fill(250);\n    this.y = new Float32Array(particleCount).fill(250);\n    this.oldX = new Float32Array(particleCount).fill(250);\n    this.oldY = new Float32Array(particleCount).fill(250);\n    this.vx = new Float32Array(particleCount);\n    this.vy = new Float32Array(particleCount);\n    this.p = new Float32Array(particleCount);\n    this.pNear = new Float32Array(particleCount);\n    this.g = new Float32Array(particleCount);\n    this.mesh = [];\n  }\n\n  _createClass(State, [{\n    key: \"getPoint\",\n    value: function getPoint(index) {\n      return new Vector2d(this.x[index], this.y[index]);\n    }\n  }, {\n    key: \"getOldPoint\",\n    value: function getOldPoint(index) {\n      return new Vector2d(this.oldX[index], this.oldY[index]);\n    }\n  }, {\n    key: \"setPoint\",\n    value: function setPoint(index, val) {\n      this.x[index] = val.x;\n      this.y[index] = val.y;\n    }\n  }]);\n\n  return State;\n}();\n\nvar GRAVITY = new Vector2d(0, 9.8);\nvar INTERACTION_RADIUS = 105;\nvar INTERACTION_RADIUS_SQ = Math.pow(INTERACTION_RADIUS, 2);\nvar STIFFNESS = 35; // NO idea what these should be.\n\nvar STIFFNESS_NEAR = 100;\nvar REST_DENSITY = 5;\n\nvar FluidService =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Contents of hashmap are index of point in state.\n   */\n  function FluidService(particleCount, width, height) {\n    var dt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0166;\n\n    _classCallCheck(this, FluidService);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"particleCount\", void 0);\n\n    _defineProperty(this, \"dt\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"radiusSq\", void 0);\n\n    _defineProperty(this, \"hashMap\", void 0);\n\n    _defineProperty(this, \"X_GRID_CELLS\", void 0);\n\n    _defineProperty(this, \"Y_GRID_CELLS\", void 0);\n\n    _defineProperty(this, \"gradient\", MemoService(function (a, b) {\n      var lsq = a.squaredDistanceTo(b);\n\n      if (lsq > INTERACTION_RADIUS_SQ) {\n        return 0;\n      }\n\n      var distance = Math.sqrt(lsq);\n      return 1 - distance / INTERACTION_RADIUS;\n    }));\n\n    this.state = new State(particleCount); // Initialize points in state randomlu\n\n    for (var i = 0; i < particleCount; i++) {\n      var pos = width / particleCount / 200 * i;\n      this.state.setPoint(i, new Vector2d(pos, pos));\n    }\n\n    this.particleCount = particleCount;\n    this.dt = dt;\n    this.width = width;\n    this.height = height; // TEMP\n\n    this.radius = this.height / 2;\n    this.radiusSq = this.radius * this.radius;\n    this.hashMap = new SpatialHashMap(this.width, this.height); // Calculate number of grid cells\n\n    this.X_GRID_CELLS = 54;\n    this.Y_GRID_CELLS = 54;\n  }\n  /**\n   * Calculates the next state\n   */\n\n\n  _createClass(FluidService, [{\n    key: \"next\",\n    value: function next() {\n      this.passOne();\n      this.passTwo();\n      this.passThree();\n      return this.state;\n    }\n  }, {\n    key: \"applyGlobalForces\",\n    value: function applyGlobalForces(index, dt) {\n      var force = GRAVITY.times(dt);\n      this.state.vx[index] += force.x;\n      this.state.vy[index] += force.y;\n    }\n  }, {\n    key: \"getXGrid\",\n    value: function getXGrid(pos) {\n      return pos / this.width * this.X_GRID_CELLS;\n    }\n  }, {\n    key: \"getYGrid\",\n    value: function getYGrid(pos) {\n      return pos / this.height * this.Y_GRID_CELLS;\n    }\n    /**\n     * Returns a *'gradient'* describing how far away these two points are.\n     * In this context, a gradient is between 0 and 1, with 1 indicating that the\n     * points are very close to eachother, and 0 indicating they are far.\n     *\n     * More concretely, 0 indicates that the points are at least `INTERACTION_RADIUS`\n     * apart.\n     * @param a first point\n     * @param b second point\n     *\n     * @returns gradient for these two points.\n     */\n\n  }, {\n    key: \"getNeighborsWithGradients\",\n\n    /**\n     * **Not Pure**\n     *\n     * Returns neighbors with a non-zero gradient and stores their\n     * gradients in the global state.\n     * @param i index of the point in state.\n     * @returns array of indexes of all neighbors\n     */\n    value: function getNeighborsWithGradients(i) {\n      var radius = INTERACTION_RADIUS / this.width * this.X_GRID_CELLS;\n      var point = this.state.getPoint(i);\n      var results = this.hashMap.query(this.getXGrid(point.x), this.getYGrid(point.y), radius);\n      var neighbors = [];\n\n      for (var k = 0; k < results.length; k++) {\n        var n = results[k];\n        if (i === n) continue; // Skip itself\n\n        var g = this.gradient(point, this.state.getPoint(n));\n        if (g === 0) continue;\n        this.state.g[n] = g; // Store the gradient\n\n        neighbors.push(n); // Push the neighbor to neighbors\n      }\n\n      return neighbors;\n    }\n    /**\n     * **Not Pure**\n     * Updates global state with pressures for this point.\n     */\n\n  }, {\n    key: \"updatePressure\",\n    value: function updatePressure(index, neighbors) {\n      var density = 0;\n      var nearDensity = 0;\n\n      for (var k = 0; k < neighbors.length; k++) {\n        var g = this.state.g[neighbors[k]]; // Get g for this neighbour\n\n        density += g * g;\n        nearDensity += g * g * g;\n      }\n\n      this.state.p[index] = STIFFNESS * (density - REST_DENSITY);\n      this.state.pNear[index] = STIFFNESS_NEAR * nearDensity;\n    }\n    /**\n     * **Not Pure**\n     * Applies density relaxation algorithm to point.\n     */\n\n  }, {\n    key: \"relax\",\n    value: function relax(index, neighbors, dt) {\n      var pos = this.state.getPoint(index);\n\n      for (var k = 0; k < neighbors.length; k++) {\n        var n = neighbors[k];\n        var g = this.state.g[n];\n        var nPos = this.state.getPoint(n);\n        var magnitude = this.state.p[index] * g + this.state.pNear[index] * g * g;\n        var direction = nPos.minus(pos).approxUnit;\n        var force = direction.times(magnitude);\n        var d = force.times(dt * dt).times(-0.05);\n        this.state.setPoint(index, this.state.getPoint(index).plus(d.times(-0.5)));\n        this.state.setPoint(n, this.state.getPoint(n).plus(d.times(0.5)));\n      }\n    }\n  }, {\n    key: \"contain\",\n    value: function contain(index) {\n      var pos = this.state.getPoint(index);\n\n      if (pos.magnitudeSquared > this.radiusSq) {\n        var unitPos = pos.normalized;\n        var newPos = unitPos.times(this.radius);\n        this.state.setPoint(index, newPos);\n      }\n    }\n  }, {\n    key: \"calculateVelocity\",\n    value: function calculateVelocity(index, dt) {\n      var pos = this.state.getPoint(index);\n      var old = this.state.getOldPoint(index);\n      var v = pos.minus(old).times(1 / dt);\n      this.state.vx[index] = v.x;\n      this.state.vy[index] = v.y;\n    }\n    /**\n     * Pass One.  Not sure what else to say about this.\n     */\n\n  }, {\n    key: \"passOne\",\n    value: function passOne() {\n      for (var i = 0; i < this.particleCount; i++) {\n        var point = this.state.getPoint(i); // Update old state\n\n        this.state.oldX[i] = point.x;\n        this.state.oldY[i] = point.y; // Apply global forces\n\n        this.applyGlobalForces(i, this.dt); // Update positions\n\n        this.state.setPoint(i, this.state.getPoint(i).plus(new Vector2d(this.state.vx[i], this.state.vy[i]).times(this.dt))); // Store points in spatial hashmap\n\n        this.hashMap.add(this.getXGrid(point.x), this.getYGrid(point.y), i);\n      }\n    }\n  }, {\n    key: \"passTwo\",\n    value: function passTwo() {\n      for (var i = 0; i < this.particleCount; i++) {\n        var neighbours = this.getNeighborsWithGradients(i);\n        this.updatePressure(i, neighbours); // perform double density relaxation\n\n        this.relax(i, neighbours, this.dt);\n      }\n\n      this.hashMap.clear();\n    }\n    /**\n     * Contain particles within a boundary.\n     */\n\n  }, {\n    key: \"passThree\",\n    value: function passThree() {\n      for (var i = 0; i < this.particleCount; i++) {\n        // Constrain the particles to a container\n        this.contain(i); // Calculate new velocities\n\n        this.calculateVelocity(i, this.dt); // Update\n        // this.state.mesh[i].position.set(state.x[i], state.y[i], 0);\n      }\n    }\n  }]);\n\n  return FluidService;\n}();\n\nexport { FluidService as default };","map":null,"metadata":{},"sourceType":"module"}