{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from \"react\";\nimport TypeWriterService from \"../../../Services/TypeWriter/TypeWriter.service\";\n/**\n * A representation of a delayed state of the typed text.\n */\n\nexport const DEFAULT_TYPE_CONFIG = {\n  typeDelay: {\n    base: 100,\n    variance: 50\n  },\n  mistakeRealizeDelay: {\n    base: 250,\n    variance: 50\n  },\n  mistakeProbability: 0.02\n};\n/**\n * Type the provided text according to the type config.\n */\n\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case \"TYPE_TEXT\":\n      let textToType = \"\";\n\n      if (state.sequence.length) {\n        // Get the value of the text once the sequence is completed.\n        // We should add the text provided to this text.\n        textToType = state.sequence[state.sequence.length - 1].text;\n      }\n\n      const typeSequence = []; // In the special case in which we're just typing an empty string, add a DelayNode\n      // to call the listener if there is one.\n\n      if (action.payload.text === \"\" && action.payload.listener) {\n        return _objectSpread({}, state, {\n          sequence: state.sequence.concat([{\n            text: textToType,\n            delay: 0,\n            listener: action.payload.listener\n          }])\n        });\n      } // Function for generating a the delay of typing a character.\n\n\n      const getTypeDelay = () => Math.max(0, action.payload.typeConfig.typeDelay.base + Math.random() * action.payload.typeConfig.typeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance); // Function for generating the delay of realizing a mistake.\n\n\n      const getMistakeDelay = () => Math.max(0, action.payload.typeConfig.mistakeRealizeDelay.base + Math.random() * action.payload.typeConfig.mistakeRealizeDelay.variance * 2 - action.payload.typeConfig.typeDelay.variance); // For each character...\n\n\n      action.payload.text.split(\"\").forEach((char, i) => {\n        // Possibly make a mistake\n        if (Math.random() <= action.payload.typeConfig.mistakeProbability) {\n          //Type mistake character\n          typeSequence.push({\n            text: textToType + TypeWriterService.getMistakeCharacter(char),\n            delay: getTypeDelay()\n          }); // Then erase it.\n\n          typeSequence.push({\n            text: textToType,\n            delay: getMistakeDelay()\n          });\n        } // The next text should include the next character\n\n\n        textToType += char; // If this is the last node to add, add the listener to the node.\n\n        if (i === action.payload.text.length - 1 && action.payload.listener) {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay(),\n            listener: action.payload.listener\n          });\n        } else {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay()\n          });\n        }\n      });\n      return _objectSpread({}, state, {\n        sequence: state.sequence.concat(typeSequence)\n      });\n\n    case \"DELETE_ALL\":\n      //Don't do anything if the current value is empty\n      if (!state.currentValue.length) {\n        return state;\n      } //Immediately delete all characters.\n\n\n      const newSequence = state.currentValue.split(\"\").slice(0, state.currentValue.length - 1) // I.E. \"123\" -> [\"12\", \"1\", \"\"]\n      .reduce((sum, char) => [sum[0] + char].concat(sum), [\"\"]) // Deletes take 10 miliseconds (this value is not configurable yet.)\n      .map(text => ({\n        text,\n        delay: 10\n      }));\n      return _objectSpread({}, state, {\n        sequence: newSequence\n      });\n\n    case \"WAIT_FOR_NEXT_NODE\":\n      return _objectSpread({}, state, {\n        isWaiting: true\n      });\n\n    case \"TYPE_NODE\":\n      return {\n        currentValue: state.sequence[0].text,\n        sequence: state.sequence.slice(1),\n        isWaiting: false\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Types some characters.  It's pretty sick.\n *\n * @param initialText - the value of text will start with this value\n * @returns [currentValueOfText, setText, isIdle]\n */\nconst useTypeWriter = (initialText = \"\") => {\n  const [state, dispatch] = React.useReducer(reducer, {\n    currentValue: initialText,\n    sequence: [],\n    isWaiting: false\n  });\n  const nextNodeTimeout = React.useRef(null);\n  React.useEffect(() => {\n    if (state.isWaiting || !state.sequence.length) {\n      return;\n    }\n\n    const nextNode = state.sequence[0];\n    dispatch({\n      type: \"WAIT_FOR_NEXT_NODE\",\n      payload: null\n    });\n    nextNodeTimeout.current = setTimeout(() => {\n      dispatch({\n        type: \"TYPE_NODE\",\n        payload: null\n      });\n\n      if (nextNode.listener) {\n        nextNode.listener();\n      }\n    }, nextNode.delay);\n  }, [state]);\n  React.useEffect(() => () => {\n    nextNodeTimeout.current !== null && clearTimeout(nextNodeTimeout.current);\n  }, []);\n  /**\n   * Use ref so this function can be used in effects and won't cause\n   * the effect to rerun after state changes.\n   */\n\n  const typeNextText = React.useRef((nextText, config) => {\n    dispatch({\n      type: \"DELETE_ALL\",\n      payload: null\n    });\n\n    const typeTextPayload = _objectSpread({}, config, {\n      //If a config.typeConfig is provided set it to the type config, otherwise use the default\n      typeConfig: config && config.typeConfig || DEFAULT_TYPE_CONFIG,\n      text: nextText\n    });\n\n    dispatch({\n      type: \"TYPE_TEXT\",\n      payload: typeTextPayload\n    });\n  });\n  return [state.currentValue, typeNextText.current, state.sequence.length === 0];\n};\n\nexport default useTypeWriter;","map":{"version":3,"sources":["/Users/danielkrajnak/Documents/Code/dankLand/src/View/Hooks/useTypeWriter/useTypeWriter.ts"],"names":["React","TypeWriterService","DEFAULT_TYPE_CONFIG","typeDelay","base","variance","mistakeRealizeDelay","mistakeProbability","reducer","state","action","type","textToType","sequence","length","text","typeSequence","payload","listener","concat","delay","getTypeDelay","Math","max","typeConfig","random","getMistakeDelay","split","forEach","char","i","push","getMistakeCharacter","currentValue","newSequence","slice","reduce","sum","map","isWaiting","useTypeWriter","initialText","dispatch","useReducer","nextNodeTimeout","useRef","useEffect","nextNode","current","setTimeout","clearTimeout","typeNextText","nextText","config","typeTextPayload"],"mappings":"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","sourcesContent":["import Action from \"../../../Domain/Action/Action\";\nimport * as React from \"react\";\nimport TypeWriterService from \"../../../Services/TypeWriter/TypeWriter.service\";\n\n/**\n * A representation of a delayed state of the typed text.\n */\nexport interface DelayNode {\n  /**\n   * The value of the text after the delay\n   */\n  text: string;\n  /**\n   * The delay in  miliseconds\n   */\n  delay: number;\n  /**\n   * A listener that should be called after this delay node executed.\n   */\n  listener?: () => void;\n}\n\n/**\n * Configure a delay\n * (typing seems more natural when it takes a semi-random amount of time between each character)\n */\ninterface DelayConfig {\n  base: number;\n  variance: number;\n}\n\n/**\n * The state maintained by the reducer.\n */\nexport interface State {\n  /**\n   * Current value of the typed text\n   */\n  currentValue: string;\n  /**\n   * Sequence of delays to be executed\n   */\n  sequence: DelayNode[];\n  /**\n   * Whether we're waiting for the next node to be typed.\n   */\n  isWaiting: boolean;\n}\n\n/**\n * A configuration for the timing of typing a text.\n */\ninterface TypeConfig {\n  /**\n   * The delay of typing characters\n   */\n  typeDelay: DelayConfig;\n  /**\n   * The delay for realizing a mistake (the delay before a mistaken character is deleted)\n   */\n  mistakeRealizeDelay: DelayConfig;\n  /**\n   * The probability that the a given character will be mistyped.\n   */\n  mistakeProbability: number;\n}\n\nexport const DEFAULT_TYPE_CONFIG: TypeConfig = {\n  typeDelay: {\n    base: 100,\n    variance: 50,\n  },\n  mistakeRealizeDelay: {\n    base: 250,\n    variance: 50,\n  },\n  mistakeProbability: 0.02,\n};\n\n/**\n * Type the provided text according to the type config.\n */\nexport type TypeTextAction = Action<\n  \"TYPE_TEXT\",\n  { text: string; typeConfig: TypeConfig; listener?: () => void }\n>;\n/**\n * Delete all characters\n */\nexport type DeleteAllAction = Action<\"DELETE_ALL\", null>;\n/**\n * Indicate that we are waiting to for the next node's delay to finish.\n * Don't pull anything off the stack.\n */\nexport type WaitForNextNodeAction = Action<\"WAIT_FOR_NEXT_NODE\", null>;\n/**\n * Set the current value to the value of the next node.\n */\nexport type TypeNode = Action<\"TYPE_NODE\", null>;\n\nexport const reducer = (\n  state: State,\n  action: TypeTextAction | DeleteAllAction | WaitForNextNodeAction | TypeNode\n): State => {\n  switch (action.type) {\n    case \"TYPE_TEXT\":\n      let textToType = \"\";\n      if (state.sequence.length) {\n        // Get the value of the text once the sequence is completed.\n        // We should add the text provided to this text.\n        textToType = state.sequence[state.sequence.length - 1].text;\n      }\n      const typeSequence: DelayNode[] = [];\n\n      // In the special case in which we're just typing an empty string, add a DelayNode\n      // to call the listener if there is one.\n      if (action.payload.text === \"\" && action.payload.listener) {\n        return {\n          ...state,\n          sequence: state.sequence.concat([\n            { text: textToType, delay: 0, listener: action.payload.listener },\n          ]),\n        };\n      }\n      // Function for generating a the delay of typing a character.\n      const getTypeDelay = () =>\n        Math.max(\n          0,\n          action.payload.typeConfig.typeDelay.base +\n            Math.random() * action.payload.typeConfig.typeDelay.variance * 2 -\n            action.payload.typeConfig.typeDelay.variance\n        );\n\n      // Function for generating the delay of realizing a mistake.\n      const getMistakeDelay = () =>\n        Math.max(\n          0,\n          action.payload.typeConfig.mistakeRealizeDelay.base +\n            Math.random() *\n              action.payload.typeConfig.mistakeRealizeDelay.variance *\n              2 -\n            action.payload.typeConfig.typeDelay.variance\n        );\n\n      // For each character...\n      action.payload.text.split(\"\").forEach((char, i) => {\n        // Possibly make a mistake\n        if (Math.random() <= action.payload.typeConfig.mistakeProbability) {\n          //Type mistake character\n          typeSequence.push({\n            text: textToType + TypeWriterService.getMistakeCharacter(char),\n            delay: getTypeDelay(),\n          });\n          // Then erase it.\n          typeSequence.push({\n            text: textToType,\n            delay: getMistakeDelay(),\n          });\n        }\n        // The next text should include the next character\n        textToType += char;\n        // If this is the last node to add, add the listener to the node.\n        if (i === action.payload.text.length - 1 && action.payload.listener) {\n          typeSequence.push({\n            text: textToType,\n            delay: getTypeDelay(),\n            listener: action.payload.listener,\n          });\n        } else {\n          typeSequence.push({ text: textToType, delay: getTypeDelay() });\n        }\n      });\n      return { ...state, sequence: state.sequence.concat(typeSequence) };\n\n    case \"DELETE_ALL\":\n      //Don't do anything if the current value is empty\n      if (!state.currentValue.length) {\n        return state;\n      }\n      //Immediately delete all characters.\n      const newSequence: DelayNode[] = state.currentValue\n        .split(\"\")\n        .slice(0, state.currentValue.length - 1)\n        // I.E. \"123\" -> [\"12\", \"1\", \"\"]\n        .reduce((sum, char) => [sum[0] + char].concat(sum), [\"\"])\n        // Deletes take 10 miliseconds (this value is not configurable yet.)\n        .map(text => ({ text, delay: 10 }));\n      return {\n        ...state,\n        sequence: newSequence,\n      };\n\n    case \"WAIT_FOR_NEXT_NODE\":\n      return { ...state, isWaiting: true };\n\n    case \"TYPE_NODE\":\n      return {\n        currentValue: state.sequence[0].text,\n        sequence: state.sequence.slice(1),\n        isWaiting: false,\n      };\n\n    default:\n      return state;\n  }\n};\n\ninterface TypeNextTextConfig {\n  /**\n   * Listener to be called when this text is finished typing\n   * *Note this listener may never be called as the text could be deleted before it is fully typed*\n   */\n  listener?: () => void;\n  /**\n   * Config for the timing of typing the text.\n   */\n  typeConfig?: TypeConfig;\n}\n\nexport type SetText = (newText: string, config?: TypeNextTextConfig) => void;\n\ntype useTypeWriterReturn = [\n  /**\n   * The value of the text\n   */\n  string,\n  /**\n   * A method to set the next text value, with a config.\n   */\n  SetText,\n  /**\n   * Whether the typewriter is idle.\n   */\n  boolean\n];\n\n/**\n * Types some characters.  It's pretty sick.\n *\n * @param initialText - the value of text will start with this value\n * @returns [currentValueOfText, setText, isIdle]\n */\nconst useTypeWriter = (initialText: string = \"\"): useTypeWriterReturn => {\n  const [state, dispatch] = React.useReducer(reducer, {\n    currentValue: initialText,\n    sequence: [],\n    isWaiting: false,\n  });\n  const nextNodeTimeout = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    if (state.isWaiting || !state.sequence.length) {\n      return;\n    }\n    const nextNode = state.sequence[0];\n    dispatch({ type: \"WAIT_FOR_NEXT_NODE\", payload: null });\n    nextNodeTimeout.current = setTimeout(() => {\n      dispatch({ type: \"TYPE_NODE\", payload: null });\n      if (nextNode.listener) {\n        nextNode.listener();\n      }\n    }, nextNode.delay);\n  }, [state]);\n\n  React.useEffect(\n    () => () => {\n      nextNodeTimeout.current !== null && clearTimeout(nextNodeTimeout.current);\n    },\n    []\n  );\n\n  /**\n   * Use ref so this function can be used in effects and won't cause\n   * the effect to rerun after state changes.\n   */\n  const typeNextText = React.useRef(\n    (nextText: string, config?: TypeNextTextConfig) => {\n      dispatch({ type: \"DELETE_ALL\", payload: null });\n      const typeTextPayload = {\n        //If config has a listener or other values, include them.\n        ...config,\n        //If a config.typeConfig is provided set it to the type config, otherwise use the default\n        typeConfig: (config && config.typeConfig) || DEFAULT_TYPE_CONFIG,\n        text: nextText,\n      };\n      dispatch({\n        type: \"TYPE_TEXT\",\n        payload: typeTextPayload,\n      });\n    }\n  );\n\n  return [\n    state.currentValue,\n    typeNextText.current,\n    state.sequence.length === 0,\n  ];\n};\n\nexport default useTypeWriter;\n"]},"metadata":{},"sourceType":"module"}